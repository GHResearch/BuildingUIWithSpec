{
	"metadata" : {
		"title" : "Advanced Widgets"
	}
}
@cha_advanced_widgets

@@todo JF REWRITE almost completely

@@todo JF add motivating intro


!! RadioButtonModel

+Screen shot of the washing machine control panel.>file://figures/Wash.png|width=30|label=fig_WashingMachine+

Radio buttons allow the user to select at most one option from a group, and unlike dropdown menus all items of this group are visible on screen. The ==RadioButtonModel== of spec uses ==RadioButtonGroup== to manage the group.

As an example UI we present a basic washing machine control panel, shown in Figure *@fig_WashingMachine*. There are two groups of radio buttons: one for the kind of fabric and one for the temperature of the water (in Celcius). Lastly, there is one more radio button that allows for an extra rinse cycle to be selected. 

The code for the UI is in a ==RadioButtonExample== class, whose definition and layout method are straightforward:

[[[
ComposableModel subclass: #RadioButtonExample
	instanceVariableNames: 'rinse f1 f2 f3 t1 t2 t3'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'

]]]

[[[
RadioButtonExample class >> defaultSpec
 ^SpecColumnLayout composed
    newRow: [:r | 
      r newColumn: [:c | c add: #f1 ; add: #f2 ; add: #f3 ];
        newColumn: [:c | c add: #t1 ; add: #t2 ; add: #t3 ]];
    newRow: [:r | r add: #rinse ];
    yourself
]]]

In the ==initializeWidgets== method, we will add the fabric radio buttons ==f1== through ==f3== to a ==fabric== button group and the temperature buttons ==t1== through ==t3== to a ==temperature== button group. Since these button groups are used nowhere else in the UI, we only have them as local variables of the method and not as instance variables of the class.

The code below shows the method. We first create both button groups, then the ==rinse== button, and then the different temperature and fabric buttons are created and added to their group. The ==rinse== button is configured to be de-selectable, and the ==f1== and ==t1== buttons are the default buttons of their respective groups, meaning they will be selected when the UI opens.

[[[
RadioButtonExample >> initializeWidgets
  | fabric temperature |
  fabric := RadioButtonGroup new.
  temperature := RadioButtonGroup new.
	
  rinse := self newRadioButton.
  rinse label: 'Rinse Extra';
	  canDeselectByClick: true.
	
  f1 := self newRadioButton.
  f1 label: 'Cotton'.
  fabric addRadioButton: f1;
    default: f1.
	
  f2 := self newRadioButton.
  f2 label: 'Synthetic'.
  fabric addRadioButton: f2.
	
  f3 := self newRadioButton.
  f3 label: 'Delicate'.
  fabric addRadioButton: f3.
	
  t1 := self newRadioButton.
  t1 label: '60'.
  temperature addRadioButton: t1;
    default: t1.
	
  t2 := self newRadioButton.
  t2 label: '40'.
  temperature addRadioButton: t2.
	
  t3 := self newRadioButton.
  t3 label: '30'.
  temperature addRadioButton: t3.
]]]

Lastly, we include some logic that will trigger on button click of the different fabric buttons. If the `Synthetic' button is selected, and the temperature is set to 60 degrees, the temperature will be lowered to 40. If the `Delicate' button is selected, the temperature will be set to 30 degrees and the other fabric buttons will be disabled, as seen in Figure *@fig_WashingMachine*. Conversely, if the `Delicate' button is deselected (because another button was selected), the other fabric buttons are enabled again.

[[[
RadioButtonExample >> initializePresenter

  f2 activationAction: [ t1 state ifTrue: [t2 state: true.]].
  f3 activationAction: [
    t1 disable; state: false.
    t2 disable; state: false.
    t3 state: true. ].
 f3 deactivationAction: [ t1 enable. t2 enable. ]
]]]

With this functionality, we have demonstrated the main features of ==RadioButtonModel== and ==RadioButtonGroup==. For additional features of these classes, we refer to the source code.

!! TextInputFieldModel
@sec_textInputFieldModel

@@todo JF REWRITE with new example. Salvage "Messages of TextInputFieldModel" section. Full code for this is in http://smalltalkhub.com/#!/~Spirita/BacASableSpirita/packages/Spec-BuildUIWithSpec

This example shows how to design a popup window asking for an input, created dynamically.

The widget is an instance of a subclass of ==ComposableModel== named ==DynamicComposableModel==.

[[[
DynamicComposableModel subclass: #DynamicalPopup
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-AdvancedWidgets'
]]]


!!! Widget instanciation

==DynamicComposableModel== :
- provide a Dictionnary ''widget'' and its getter ==widget==.
- specialize ==instantiateModels:== to put widgets instanciated in the Dictionary using their names as keys and created instance as values.
- specialize ==doesNotUnderstand:== to access these widgets by a search on the Dictionary before rise an exception, so creating acessors is not required (and could break the widget). Notice that this mechanism is used in the code *@ex_popup_initializewidget* to specified the focusOrder.

[[[
DynamicalPopup >> initializeWidgets
	"Widgets instanciation"
	self instantiateModels: #(#label #LabelModel #textInput #TextInputFieldModel).

	"Widgets configuration specification"
	self title: 'Choose your project'.
	self label label: 'Packages :'.
	self textInput
		autoAccept: true;
		entryCompletion: nil;
		ghostText: '.*';
		bindKeyCombination: Character cr toAction: [ self toolbar triggerOkAction ].

	"Defining dynamically the layout"
	self
		layout:
			(SpecLayout composed
				newRow: [ :row |
					row
						add: #label origin: 0 @ 0 corner: 0.3 @ 1;
						add: #textInput origin: 0.3 @ 0 corner: 1 @ 1 ];
				yourself).

	"specification of order of focus"
	self focusOrder add: self textInput
]]]


!!! Messages of TextInputFieldModel

In Widgets configuration specification,

==ComposableModel== provides:
- Message ==bindKeyCombination:== set a shortcut associate at a block to perfom, here it make the entry key the same effect than a click on the ''Ok'' button.

@@todo JF also see pharo-users mail 28/10/15 wrt overriding existing shortcuts.

==TextModel== provides:
- Message ==autoAccept:== specify that the text field should automatically accept the text on each keystroke, such that it does not show the yellow 'edited' triangle on the top right and content don't need to be saved.

The API of ==TextInputFieldModel== provides:
- Message ==entryCompletion:== set an instance ==EntryCompletion== to treat the input.
- Message ==ghostText:== set the text of the ghost text.


!!! Set the layout dynamically

==DynamicComposableModel== provide a variable ''layout'' and its setter ==layout:==, and it specialize ==openWithSpec== to try to use this layout if it has been specified before use the search of ==ComposableModel==.

!!! Set an Action at ''Ok''

[[[
DynamicalPopup >> defaultToolbarConfiguration
	self window okAction: [ Transcript show: self inputText text ]
]]]

The message ==okAction:== set a block to perform when the ''Ok'' button is clicked, here we simply print the content of the field in the Transcript.

That method must be called after the instanciation of the window.

[[[
DynamicalPopup >> exampleDefaultToolbar
	| example |
	example := self new.
	example openDialogWithSpec.
	example defaultToolbarConfiguration
]]]

+Render of the Popup>file://figures/Popup.png|width=50|label=fig_popup+


!!! Change the Toolbar

To get a widget with a single button ''Ok'', the toolbar to use should be defined explicitly using the window's accessor ==toolbar:==.

[[[
DynamicalPopup >> alternativeToolbar
	"Instanciate the alternative toolbar"
	self instantiateModels: #(#toolbar #OkToolbar).

	"Configuring the alternative toolbar"
	self toolbar okAction: [ Transcript show: self textInput text ].

	"Set the alternative toolbar in the window"
	self window toolbar: self toolbar
]]]

That method must be called after the instanciation of the window.

[[[
DynamicalPopup >> exampleAlternativeToolbar
	| example |
	example := self new.
	example openDialogWithSpec.
	example alternativeToolbar
]]]


+Render of the Popup with a New Toolbar>file://figures/Popup_NewToolbar.png|width=50|label=fig_popup_newtoolbar+



!! Menus
@sec_littletoolbar

@@todo JF a less in-depth rewrite is feasible

@@todo JF missing explanation of menu on a text field or on a list. Also, what can we rescue from  ApplicationWithToolbar? Ben sais: "MenuModel can be used in two cases: to define a toolbar, or to define a contextual menu."

This example shows the creation of menu, a menu is the collaboration between three classes:
- ==MenuModel== containing ==MenuGoupModel== and displaying them spepareted by a splitter.
- ==MenuGoupModel== containing ==MenuItemModel==.
- ==MenuItemModel==, each of them will be a button in the menu, they wears their behaviour and their appearence.

The message ==applyTo:== links the shorcuts of the menu at a model. Making them usable, even if the menu is not displayed.

[[[
LittleToolbar >> initializeWidgets
	menu := self instantiate: MenuModel.
	self configMainMenu.
	menu applyTo: self
]]]

Here, the layout dislay simply the menu.

[[[
LittleToolbar >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newColumn: [ :column | column add: #menu ];
		yourself
]]]

- The message ==addGroup:== is provided by ==MenuModel== to create a new ==MenuGoupModel==.
- The message ==addItem:== is provided by ==MenuGoupModel== to create a new ==MenuItemModel==.

==MenuItemModel== provides the following methods to control its apperence:
- ==name:== is the text appearring at in the button.
- ==icon:== is the icon appearring at in the button.
- ==description:== is diplayed in a tooltips.
- ==shortcut:== to add a shorcut to activate the item,the shortcut is diplayed near the name.

And to control the following methods its behaviour, it should be defined only one in the same time:
- ==subMenu:== to open the specified menu.
- ==action:== to perform the specified block.

[[[
LittleToolbar >> configMainMenu
	menu
		addGroup: [ :group1 |
			group1
				addItem: [ :item |
					item
						name: 'File';
						subMenu: self createSubMenu ].
			group1
				addItem: [ :item |
					item
						description: 'Open file';
						icon: (Smalltalk ui icons iconNamed: #openIcon);
						action: [ self inform: 'Open File' ] ] ];
		addGroup: [ :group2 |
			group2
				addItem: [ :item |
					item
						description: 'Add menu item';
						icon: (Smalltalk ui icons iconNamed: #add);
						action: [ self dynamicalAdding: group2 ] ] ]
]]]

==createSubMenu== return a new MenuModel with two items.

[[[
LittleToolbar >> createSubMenu
	^ MenuModel new
		addGroup: [ :group |
			group
				addItem: [ :item |
					item
						name: 'Save';
						icon: (Smalltalk ui icons iconNamed: #smallSaveIcon);
						shortcut: $s meta;
						action: [ self inform: 'Save' ] ].
			group
				addItem: [ :item |
					item
						name: 'Print';
						shortcut: $p meta;
						icon: (Smalltalk ui icons iconNamed: #smallPrintIcon);
						action: [ self inform: 'Print' ] ] ]
]]]

@@todo JF move this to dynamic spec

==dynamicalAdding:== creates a new item, configures the item to remove itself when is clicked and adds the item to the specified group.

[[[
LittleToolbar >> dynamicalAdding: aGroup
	aGroup
		addItem: [ :item |
			item
				name: 'Dynamic';
				icon: (Smalltalk ui icons iconNamed: #delete);
				action: [ aGroup menuItems remove: item.
					self needRebuild: false.
					self buildWithSpec ] ].
	self needRebuild: false.
	self buildWithSpec
]]]

The figure *@fig_LittleToolbar* show the result after two clicks on the button to add an item and a click on the button displaying a submenu

+Render of LittleToolbar>file://figures/LittleToolbar.png|width=50|label=fig_LittleToolbar+

!! TabModel
@sec_TabModel

@@todo JF write me
