{
	"metadata" : {
		"title" : "Advanced Widgets"
	}
}
@cha_advanced_widgets

@@todo JF REWRITE almost completely

@@todo JF add motivating intro


!! RadioButtonModel
@sec_RadioButtonModel

+Screen shot of the washing machine control panel.>file://figures/Wash.png|width=30|label=fig_WashingMachine+

Radio buttons allow the user to select at most one option from a group, and unlike dropdown menus all items of this group are visible on screen. The ==RadioButtonModel== of spec uses ==RadioButtonGroup== to manage the group.

As an example UI we present a basic washing machine control panel, shown in Figure *@fig_WashingMachine*. There are two groups of radio buttons: one for the kind of fabric and one for the temperature of the water (in Celcius). Lastly, there is one more radio button that allows for an extra rinse cycle to be selected. 

The code for the UI is in a ==RadioButtonExample== class, whose definition and layout are straightforward:

[[[
ComposableModel subclass: #RadioButtonExample
	instanceVariableNames: 'rinse f1 f2 f3 t1 t2 t3'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'

]]]

[[[
RadioButtonExample class >> defaultSpec
	^SpecColumnLayout composed
		newRow: [:r | 
			r newColumn: [:c | c add: #f1 ; add: #f2 ; add: #f3 ];
			newColumn: [:c | c add: #t1 ; add: #t2 ; add: #t3 ]];
		newRow: [:r | r add: #rinse ];
		yourself
]]]

[[[
RadioButtonExample >> extent
	^160@150
]]]

In the ==initializeWidgets== method, we will add the fabric radio buttons ==f1== through ==f3== to a ==fabric== button group and the temperature buttons ==t1== through ==t3== to a ==temperature== button group. Since these button groups are used nowhere else in the UI, we only have them as local variables of the method and not as instance variables of the class.

The code below shows the method. We first create both button groups, then the ==rinse== button, and then the different temperature and fabric buttons are created and added to their group. The ==rinse== button is configured to be de-selectable, and the ==f1== and ==t1== buttons are the default buttons of their respective groups, meaning they will be selected when the UI opens.

[[[
RadioButtonExample >> initializeWidgets
	| fabric temperature |
	fabric := RadioButtonGroup new.
	temperature := RadioButtonGroup new.
	
	rinse := self newRadioButton.
	rinse label: 'Rinse Extra';
		canDeselectByClick: true.
	
	f1 := self newRadioButton.
	f1 label: 'Cotton'.
	fabric addRadioButton: f1;
		default: f1.
	
	f2 := self newRadioButton.
	f2 label: 'Synthetic'.
	fabric addRadioButton: f2.
	
	f3 := self newRadioButton.
	f3 label: 'Delicate'.
	fabric addRadioButton: f3.
	
	t1 := self newRadioButton.
	t1 label: '60'.
	temperature addRadioButton: t1;
		default: t1.
	
	t2 := self newRadioButton.
	t2 label: '40'.
	temperature addRadioButton: t2.
	
	t3 := self newRadioButton.
	t3 label: '30'.
	temperature addRadioButton: t3.
]]]

Lastly, we include some logic that will trigger on button click of the different fabric buttons. If the `Synthetic' button is selected, and the temperature is set to 60 degrees, the temperature will be lowered to 40. If the `Delicate' button is selected, the temperature will be set to 30 degrees and the other fabric buttons will be disabled, as seen in Figure *@fig_WashingMachine*. Conversely, if the `Delicate' button is deselected (because another button was selected), the other fabric buttons are enabled again.

[[[
RadioButtonExample >> initializePresenter

	f2 activationAction: [ t1 state ifTrue: [t2 state: true.]].
	f3 activationAction: [
		t1 disable; state: false.
		t2 disable; state: false.
		t3 state: true. ].
	f3 deactivationAction: [ t1 enable. t2 enable. ]
]]]

With this functionality, we have demonstrated the main features of ==RadioButtonModel== and ==RadioButtonGroup==. For additional features of these classes, we refer to the source code.

!! TabModel
@sec_TabModel

A second set of classes that are made to work together are the ==TabManagerModel== and the ==TabModel== classes. In a tabbed UI, the former holds the organisation of the different tabs, and the latter represent the tabs themselves. To show how both these classes cooperate, we will extend the washing machine example from section *@sec_RadioButtonModel* to a washer-dryer machine. It has a tabbed UI, were one tab is for the washing part, a second tab for the spin cycle and drying, and a third tab shows information.

To use tabs, only the ==TabManagerModel== needs to be kept as an instance variable of the UI, and added to the layout:

[[[
ComposableModel subclass: #TabMgrExample
	instanceVariableNames: 'tabmgr'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'
]]]

[[[
TabMgrExample >> extent
	^250@160
]]]

[[[
TabMgrExample class >> defaultSpec
	^SpecLayout composed
		add: #tabmgr;
		yourself
]]]

To show tabs, these need to be added to the tab manager using the ==addTab:== method, as shown below:

[[[
TabMgrExample >> initializeWidgets
	| tab |
	
	tabmgr := self newTabManager.
	
	tab := self newTab.
	tab model: RadioButtonExample new.
	tab label: 'Wash'; closeable: false;
		icon: Smalltalk ui icons smallScreenshot.
	tabmgr addTab: tab.
]]]

After creating the ==TabManagerModel==, the code creates a ==TabModel== and configures it to show an instance of the ==RadioButtonExample== class. The ==model:== message takes any ==ComposableModel==, following the spirit of UI reuse in Spec. Lastly, additional attributes of the tab are set: a label, an icon, and the tab is made non-closable.

This is all we need to have a first version of the UI, showing the UI of section *@sec_RadioButtonModel* as a tab. 

The ==TabManagerModel== is dynamic: new tabs can be added and tabs can be removed when the UI is open. To do this, it is sufficient to send the messages ==addTab:== and ==removeTab:== to a ==TabManagerModel==, with as argument the tab to be added, resp. removed. Closable tabs have a close button that allows the used to remove them from the UI as well.

To add the second part of the user interface, for drying the clothes, we extend ==initializeWidgets== as follows:

[[[
TabMgrExample >> initializeWidgets

	[...]

	tab := self newTab.
	tab model: (self dryModel).
	tab label: 'Dry'; closeable: false;
		icon: Smalltalk ui icons smallNew.
	tabmgr addTab: tab.

]]]

The tab needs to be configured with an instance of a ComposableModel, which typically means that there is a UI class for each tab in the UI. In some cases it may however be too heavyweight to create a class for a simple UI tab. It is therefore also possible to use dynamic Spec (see Chapter *@cha_dynamic_spec*) to create the contents of a tab.

For example, the code of ==dryModel== configures a ==DynamicComposableModel== to show two sliders. The first selects the maximum speed of the spin cycle, and the second how long the drying cycle should last.

[[[
TabMgrExample >> dryModel
	| model |

	model := DynamicComposableModel new.
	model instantiateModels: #(
		spin SliderModel
		dry SliderModel).
	
	model spin label: 'Spin speed'; min: 400; max: 1600; quantum: 400.
	model dry label: 'Dry time'; min: 0; max: 120; quantum: 10.
	
	model layout: (
		SpecColumnLayout composed
			add: #spin height: 30;
			add: #dry height: 30;
			yourself).
		
	^model.
]]]

@@note We strongly discourage the use of ==DynamicComposableModel== for anything except the most simple UIs. Please see Section *@sec_hacking_dynamic* for more considerations about the use of ==DynamicComposableModel==.

Lastly, our UI contains an `info' tab, which allows us to illustrate the ability of ==TabManager== to obtain the selected tab, and take actions on tab selection. The `info' tab will hold a ==status== text field, that we keep as an instance variable and initialize before creating the tab.

[[[
ComposableModel subclass: #TabMgrExample
	instanceVariableNames: 'tabmgr status'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'
]]]

[[[
TabMgrExample >> initializeWidgets

	[...]
	
	self createStatus.
	tab := self newTab.
	tab model: status.
	tab label: 'Info'; closeable: false;
		icon: Smalltalk ui icons smallInfo.
	tabmgr addTab: tab.
]]]

In the ==createStatus== method, we instantiate a ==TextModel==, disable it so that the user cannot edit it, and set its initial text:

[[[
TabMgrExample >> createStatus

	status := TextModel new.
	status disable;
		text: 'Welcome to Washing Machine 2.0!\History: Wash ' withCRs.
]]]

Lastly, in ==initializePresenter== we state that when a tab is selected, the label of the currently selected tab is added to the status text. This in effect creates a navigation history, completing the UI of our washer-dryer machine.

[[[
TabMgrExample >> initializePresenter

	tabmgr whenTabSelected: [
		status text: (String streamContents: [:s |
			s nextPutAll: status text.
			s nextPutAll: ' > '.
			s nextPutAll: tabmgr selectedTab label])].
]]]

!! Toolbars and Pop-up Menus

Both toolbars and pop-up menus in Spec are the result of a collaboration between three classes:
- A ==MenuModel== containing different ==MenuGroupModel== instances and displaying them, separated by a splitter.
- Multiple ==MenuGroupModel== instances, each containing a number of ==MenuItemModel== instances.
- Various ==MenuItemModel== instances, each representing a menu item with a specific appearance and behaviour.

Spec currently does not provide straightforward support for contextual menus on the UI. It is however easy to add a toolbar to a UI, as it is just another widget that is added to the layout. For example, consider the ==WatchpointWindow== class that is standard in Pharo 5. It has a menu held in its ==menu== instance variable, and its layout method places the toolbar as first widget of a column of widgets:

[[[
WatchpointWindow >> defaultSpec
	^ SpecColumnLayout composed
			add: #menu height: self toolbarHeight;
			add: #list;
			add: #inspectIt height: self toolbarHeight
]]]

The ==MenuModel== class is the only class that should be instantiated
by the programmer. To create a group, send ==addGroup:== to a
==MenuModel==, with a block as argument. This will create the group and
add it to the menu. The block receives one argument: the
instance of the group that was created. Similarly, sending ==addItem:==
to that ==MenuGroupModel== creates a new ==MenuItemModel== and adds it to the
group. The argument of ==addItem:== is also a 1-argument block, and
this argument is the menu item that is created. While this explanation may sound confusing, the resulting code is quite readable, as will be shown in the example below. 

==MenuItemModel== provides the following methods for configuration:
- ==name:== sets the text of the menu item. 
- ==icon:== sets the icon.
- ==description:== adds a tool-tip.
- ==shortcut:== adds a shorcut for the item.
- ==action:== adds a block to execute when the item is selected.
- ==subMenu:== takes a ==MenuModel== that represents the submenu that corresponds to this item.

Since ==MenuItemModel== is meant to be used both as a toolbar and a menu item, it is possible to create menu items without text or without icons, and the tool-tip works both when used as a toolbar and as a menu item. The last two configuration options: executing an action or opening a submenu are ""not"" mutually exclusive. For example, in a menu hovering over an item with a submenu opens the submenu, but still allows for the menu item itself to be selected.

To show the construction of a menu, we expand our washing machine example of the previous sections. We add a menu for technicians to use when troubleshooting or fixing the machine. To do this, we add a ==menu== instance variable and accessors to the ==TabMgrExample== class as well as a ==populateMenu== method. The ==initializeWidgets== method is appended with a ==self populateMenu== line, and the code of this method is as follows:

[[[
TabMgrExample  >> populateMenu
	| submenu |

	menu := MenuModel new.
	submenu := MenuModel new.

	submenu addGroup: [ :group |
			group addItem: [ :item |
				item name: 'Soft Reset';
					action: [ status text: 'History: Wash '.];
					icon: Smalltalk ui icons exception].
			group addItem: [ :item|
				item name: 'Hard Reset';
					action: [ GrowlMorph openWithContents: 'Just pull the plug!' ];
					icon: Smalltalk ui icons smallError ]
			 ].
]]]

After defining a ==submenu== temporary variable, the code above initialises both the ==menu== and ==submenu== variables to a fresh ==MenuModel== instance. For the sake of the example, the code first constructs the submenu, adding a soft and hard reset menu item with their respective icons and actions. The code for these menu items is straightforward (we assume the ==GrowlMorph== also works on our washing machine). 

We now continue with the definition of the main menu. As said previously, there is no easy way to create a contextual menu that pops up when the right mouse button is clicked. It is possible to show a pop-up menu by sending ==buildWithSpecAsPopup popUpInWorld== to a ==MenuModel== instance, but binding this code to a right mouse click is not straightforward.

A workaround we use here is to define a menu item that pops up the menu when it is selected. This seems like creating a chicken and egg problem, since there is no way to select the menu item when the menu is not visible! This is however not the case: we can associate a shortcut key to the menu item, so pressing the shortcut reveals the menu.

The code below continues the ==populateMenu== method and populates the main menu. The first item is the menu revealing item. It is triggered by pressing control-r on Windows and Linux, and command-r on Mac, as specified by the ==$r meta== key combination. This menu item also shows how to specify a tooltip. The rest of the code is straightforward.

[[[
	menu addGroup: [ :group |
		group addItem: [ :item |
			item name: 'Reveal this menu';
				action: [menu buildWithSpecAsPopup popUpInWorld];
				description: 'This entry exits to have a shortcut for this menu.';
				shortcut: $r meta
			].
		group addItem: [ :item |
			item name: 'Status Info';
				action: [ GrowlMorph openWithContents: tabmgr selectedTab label];
				icon: Smalltalk ui icons help].
		].
]]]

Lastly, we add a second group to the main menu, causing a splitter to appear between the above two items and the below item. This last item simply shows the submenu that we created at the beginning of the method.

[[[
	menu addGroup: [ :group |
		group addItem: [ :item |
			item name: 'Actions';
				subMenu: submenu.
			 ]
		].
	
	menu applyTo: self. 
]]]

At the very end of the method, the ==applyTo:== method is sent to the menu, causing the shortcuts defined in it to be registered to the ==TabMgrExample== widget. This is what makes pressing a shortcut of a menu item trigger the action of that menu item.

Nothing else is needed to associate the menu to the UI. There is no need to add the menu in a layout method, since our example does not have a toolbar widget shown. However, in case of adding a toolbar the ==menu== will need to be added to the layout, as we have shown in the ==WatchpointWindow== example at the beginning of this section.

Last but not least, menus are not completely static: menu items can be disabled and enabled by sending ==enabled: false==, resp. ==enabled: true== to them. The structure of a menu can also be changed by adding and removing items and groups. In the example above, since the menu is rebuilt on each pop-up such changes are immediately visible. In contrast, when used as a toolbar the menu is a widget, so the UI will need to be rebuilt as discussed in Chapter *@cha_dynamic_spec*.


!! TextInputFieldModel
@sec_textInputFieldModel

@@todo JF REWRITE with new example. Salvage "Messages of TextInputFieldModel" section. Full code for this is in http://smalltalkhub.com/#!/~Spirita/BacASableSpirita/packages/Spec-BuildUIWithSpec

This example shows how to design a popup window asking for an input, created dynamically.

The widget is an instance of a subclass of ==ComposableModel== named ==DynamicComposableModel==.

[[[
DynamicComposableModel subclass: #DynamicalPopup
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-AdvancedWidgets'
]]]


!!! Widget instanciation

==DynamicComposableModel== :
- provide a Dictionnary ''widget'' and its getter ==widget==.
- specialize ==instantiateModels:== to put widgets instanciated in the Dictionary using their names as keys and created instance as values.
- specialize ==doesNotUnderstand:== to access these widgets by a search on the Dictionary before rise an exception, so creating acessors is not required (and could break the widget). Notice that this mechanism is used in the code *@ex_popup_initializewidget* to specified the focusOrder.

[[[
DynamicalPopup >> initializeWidgets
	"Widgets instanciation"
	self instantiateModels: #(#label #LabelModel #textInput #TextInputFieldModel).

	"Widgets configuration specification"
	self title: 'Choose your project'.
	self label label: 'Packages :'.
	self textInput
		autoAccept: true;
		entryCompletion: nil;
		ghostText: '.*';
		bindKeyCombination: Character cr toAction: [ self toolbar triggerOkAction ].

	"Defining dynamically the layout"
	self
		layout:
			(SpecLayout composed
				newRow: [ :row |
					row
						add: #label origin: 0 @ 0 corner: 0.3 @ 1;
						add: #textInput origin: 0.3 @ 0 corner: 1 @ 1 ];
				yourself).

	"specification of order of focus"
	self focusOrder add: self textInput
]]]


!!! Messages of TextInputFieldModel

In Widgets configuration specification,

==ComposableModel== provides:
- Message ==bindKeyCombination:== set a shortcut associate at a block to perfom, here it make the entry key the same effect than a click on the ''Ok'' button.

@@todo JF also see pharo-users mail 28/10/15 wrt overriding existing shortcuts.

==TextModel== provides:
- Message ==autoAccept:== specify that the text field should automatically accept the text on each keystroke, such that it does not show the yellow 'edited' triangle on the top right and content don't need to be saved.

The API of ==TextInputFieldModel== provides:
- Message ==entryCompletion:== set an instance ==EntryCompletion== to treat the input.
- Message ==ghostText:== set the text of the ghost text.


!!! Set the layout dynamically

==DynamicComposableModel== provide a variable ''layout'' and its setter ==layout:==, and it specialize ==openWithSpec== to try to use this layout if it has been specified before use the search of ==ComposableModel==.

!!! Set an Action at ''Ok''

[[[
DynamicalPopup >> defaultToolbarConfiguration
	self window okAction: [ Transcript show: self inputText text ]
]]]

The message ==okAction:== set a block to perform when the ''Ok'' button is clicked, here we simply print the content of the field in the Transcript.

That method must be called after the instanciation of the window.

[[[
DynamicalPopup >> exampleDefaultToolbar
	| example |
	example := self new.
	example openDialogWithSpec.
	example defaultToolbarConfiguration
]]]

+Render of the Popup>file://figures/Popup.png|width=50|label=fig_popup+


!!! Change the Toolbar

To get a widget with a single button ''Ok'', the toolbar to use should be defined explicitly using the window's accessor ==toolbar:==.

[[[
DynamicalPopup >> alternativeToolbar
	"Instanciate the alternative toolbar"
	self instantiateModels: #(#toolbar #OkToolbar).

	"Configuring the alternative toolbar"
	self toolbar okAction: [ Transcript show: self textInput text ].

	"Set the alternative toolbar in the window"
	self window toolbar: self toolbar
]]]

That method must be called after the instanciation of the window.

[[[
DynamicalPopup >> exampleAlternativeToolbar
	| example |
	example := self new.
	example openDialogWithSpec.
	example alternativeToolbar
]]]


+Render of the Popup with a New Toolbar>file://figures/Popup_NewToolbar.png|width=50|label=fig_popup_newtoolbar+
