{ "title" : "Dynamic Spec"}


!! ProtocolBrowser dynamic Version

Having an user interface with a well known number of sub widgets and a static layout is not always sufficient. 
A user interface is often more than just that, for example here are two situations where more is needed: 
First, when the layout of the user interface needs to be changed at runtime to match the execution context of the software.
Second, sub widgets are added or removed at runtime and therefore the programmer needs to be able to parametrize those new sub widgets on the fly.

''Spec'' also provides support for such dynamic user interfaces.
In this section we show how to use ''Spec'' in these situations.

First, we talk about making dynamic modifications of the layout of widgets, and second we discuss the dynamic adding and removing of subwidgets.
Third and last we show how the dynamic features can be used to quickly prototype a user interface.



!!! Dynamic modification of the layout

Changing the layout of widgets at runtime is straightforward, as we will see here.

Such changes basically consist of three steps:
- First, create the new layout.
- Second, the ==needRebuild== flag is set to ==false== to prohibit the creation of a new UI element (and reuse the existing one).
- Third, the rebuilding of the user interface is performed.

One widget can also keep the UI elements of its sub widgets which do not need to be rebuilt.
The message ==needRebuild: false== needs to be sent to any of those sub widgets.

For example, if a model comprising a ''button'' and a ''list'' just wants to rearrange the position of these UI elements, there is no need to rebuild them. As shown in the example *@ex_needRebuild*

[[[label=ex_needRebuild|caption=How to need rebuild sub widgets|language=Smalltalk 
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false.
	theButton needRebuild: false.
	theList needRebuild: false.
	self buildWithSpecLayout: newLayout.
]]]



!!! Dynamic adding and removal of subwidgets

If a user interface needs a varying number of subwidgets, the amount of which cannot be established at compilation time, then another approach is needed.
In this scenario, ==DynamicComposableModel== is the model that needs to be subclassed, as this class provides support for the required kind of dynamic behavior.

Amongst others, this class adds the method ==assign:to:==, which takes a model instance as a first argument, and a unique symbol as a second argument.
This method is used to assign an already instantiated model as sub widget, instead of the method ==instantiateModels:== that takes a class name as argument and instantiates a new model.

When using ==DynamicComposableModel==, the instantiation of the sub widgets is a bit different from normal use.
In the ==instantiateWidgets== method, instead of instantiating each widget separately, ==instantiateModels:== should be used to instantiate them.
This method takes as argument an array of pairs, where each pair is composed of the unique name of the widget as key, and the name of the widget class as value.
This allows for a widget to be accessed by sending a message whose selector is the widget name to the model.

By example, if a widget named ==button== is created, then this widget can be accessed by calling ==self button== as shown in the example *@ex_dynamic_creation*.

[[[label=ex_dynamic_creation|caption=Dynamic creation of a widget|language=Smalltalk 
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

!!! Examples: Prototyping a UI

Thanks to the capability of ''Spec'' to dynamically instantiate widgets, it is also possible to prototype a user interface from within any workspace.
The following examples show how ''Spec'' can be used to quickly prototype a user interace.

The first example explains how to design by prototyping a user interface.
The second example introduces the composition of dynamic models.


The result can be seen in Figure *@fig_popup*.


!!!! Composing dynamic models

This exemple shows in three parts how to buid a simple code browser.

First a simple list widget is created displaying all the subclasses of AstractWidgetModel.

Then the list widget is reused to build a viewer widget displaying the protocol methods of the selected class.

Finally the last widget is defined with the previously created viewer.
In addition, a text zone is added to show the selected methods source code.

The final result looks like the Figure *@fig_browser*.

[[[label=code_to_integrate|caption=Code to integrate|language=Smalltalk


| dynamicWidgetClassList dynamicProtocolViewer dynamicProtoclBrowser |
	dynamicWidgetClassList := DynamicComposableModel new.
	dynamicWidgetClassList instantiateModels: #(#list #ListModel).
	dynamicWidgetClassList list items: (AbstractWidgetModel allSubclasses sorted: [ :a :b | a name < b name ]).
	dynamicWidgetClassList
		layout:
			(SpecLayout composed
				add: #list;
				yourself).
	dynamicWidgetClassList openWithSpec.
	dynamicProtocolViewer := DynamicComposableModel new.
	dynamicProtocolViewer assign: dynamicWidgetClassList to: #classes.
	dynamicProtocolViewer instantiateModels: #(#methods #ListModel).
	dynamicWidgetClassList list
		whenSelectedItemChanged: [ :item | 
			item
				ifNil: [ dynamicProtocolViewer methods items: #() ]
				ifNotNil: [ dynamicProtocolViewer methods items: (item selectorsInProtocol: 'api') sorted ] ].
	dynamicProtocolViewer
		layout:
			(SpecLayout composed
				newRow: [ :r | 
					r
						add: #classes;
						add: #methods ];
				yourself).
	dynamicProtocolViewer openWithSpec.
	dynamicProtoclBrowser := DynamicComposableModel new.
	dynamicProtoclBrowser assign: dynamicProtocolViewer to: #top.
	dynamicProtoclBrowser instantiateModels: #(#text #TextModel).
	dynamicProtocolViewer methods
		whenSelectedItemChanged: [ :selector | 
			selector
				ifNil: [ dynamicProtoclBrowser text text: '' ]
				ifNotNil: [ dynamicProtoclBrowser text text: (dynamicWidgetClassList list selectedItem >> selector) sourceCode ] ].
	dynamicProtoclBrowser
		layout:
			(SpecLayout composed
				newColumn: [ :c | 
					c
						add: #top;
						add: #text ];
				yourself).
	dynamicProtoclBrowser openWithSpec.
	dynamicProtoclBrowser title: 'Protocol browser'
]]]

+Prototype of Protocol Browser>file://figures/Dyn_Protocol_Browser.png|width=50|label=fig_browser+


!! The Adresse Book

In an address book we find addresses of both people and organizations. 
The generalization of both is called a ''party'' ('Analysis Patterns', Martin Fowler). 
In this example we'll make an address book where we can add both persons and companies.
They will have different attributes.
We show how to do add them with a dynamic user interface, and minimize duplication.


!! The party model
In the party model, party is a superclass of person and company. 

+UML Diagram of the Adress Book>file://figures/do.png|label=fig_do_diagram+

Create the abstract superclass ==Party==
[[[label=createParty|caption=Create the party class|language=Smalltalk 
Object subclass: #DOParty
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Domain-Parties'
]]]

We should be able to select parties from a list. 
A party responds to the ==fullName== message. 

[[[label=partyName|caption=Select a party by its full name|language=Smalltalk 
DOParty>>fullName
	^'Full name'
]]]

The subclasses are going to override this message.
Create a subclass for persons:

[[[label=createPerson|caption=Create person as a subclass of party|language=Smalltalk 
DOParty subclass: #DOPerson
	instanceVariableNames: 'firstName lastName'
	classVariableNames: ''
	package: 'Domain-Parties'
]]]

Create accessors for ==firstName== and ==lastName==. We don't want to need to handle ==nil==
as a special case, so return the empty string if the instVars are nil.

[[[label=personAccessors|caption=Accessors for person|language=Smalltalk 
DOPerson>>firstName
	^firstName ifNil: [ '' ]
	
DOPerson>>firstName: aString
	firstName := aString

DOPerson>>lastName
	^lastName ifNil: [ '' ]

DOPerson>>lastName: aString
	lastName := aString
]]]

We can now override the ==fullName==.

[[[label=overrideFullname|caption=Override the full name|language=Smalltalk 
DOPerson>>fullName
	^self firstName, ' ', self lastName
]]]

Create a subclass for companies

[[[label=createCompany|caption=Create company as subclass of party|language=Smalltalk 
DOParty subclass: #DOCompany
	instanceVariableNames: 'companyName'
	classVariableNames: ''
	package: 'Domain-Parties'
]]]

And its accessors and the overridden method

[[[label=companyAccessors|caption=Accessors and override for company|language=Smalltalk 
DOCompany>>companyName
	^ companyName ifNil: ['']
	
DOCompany>>companyName: anObject
	companyName := anObject
	
DOCompany>>fullName
	^ self companyName 
]]]

In this example we will simply keep all parties in the image.
We create a class to hold parties

[[[label=partyHolder|caption=Domain model for parties|language=Smalltalk 
Object subclass: #DOPartiesModel
	instanceVariableNames: 'parties'
	classVariableNames: ''
	package: 'Domain-Parties'
]]]

And lazily initialize  with a collection

[[[label=lazyInstantiation|caption=Accessors, lazily initialized|language=Smalltalk 
DOPartiesModel>>parties
	^parties ifNil: [ parties := OrderedCollection new ]
	
DOPartiesModel>>parties: aCollection
	parties := aCollection
]]]

On the class side we add an instanceVariable ==default== as the singleton
and two methods to access and reset it.

[[[label=partiesSingleton|caption=A singleton to hold all parties|language=Smalltalk 
DOPartiesModel class
	instanceVariableNames: 'default'
	
DOPartiesModel class >>default
	^default ifNil: [ default := self new ]
	
DOPartiesModel class >>reset
	default := nil
]]]

!! A dynamic editor
To edit a single party, we create a subclass of ==DynamicComposableModel==

[[[label=partyEditor|caption=A class to edit one party|language=Smalltalk 
DynamicComposableModel subclass: #DOPartyEditor
	instanceVariableNames: 'partyClass'
	classVariableNames: ''
	package: 'Domain-Parties'
]]]
When we instantiate this editor, we'll tell it on what kind of party it operates and store that in the
 ==partyClass==. On the instance side we add accessors and on the class side we use that in a constructor.
A ==DynamicComposableModel== has a complex initialization proces, so we use a separate ==basicNew==
and ==initialize== to set the ==partyClass== early enough.
[[[label=kindOfParty|caption=The class needs to know what kind of party to edit|language=Smalltalk 
DOPartyEditor>>partyClass: aPartyClass
	partyClass := aPartyClass
	
DOPartyEditor>>partyClass
	^partyClass
	
DOPartyEditor class>>on: aPartyClass
	^self basicNew
		partyClass: aPartyClass;
		initialize;
		yourself
]]]
This class has no ==defaultSpec==, as it is only created with a dynamic spec.
The editor is going to be a separate window. The window title is dependent of the class.
Party and subclasses define it at the class side.

[[[label=kindOfParty|caption=Party editor wants to show the kind of party|language=Smalltalk 
DOParty class>>title
	"override in subclasses"
	^'Party'

DOCompany class >>title
	^'Company'
	
DOPerson class >>title
	^'Person'

DOPartyEditor>>title
	^ partyClass title
]]]

The editor needs to know what fields need to be created. On the class side of the Party subclasses
we return an array of symbols representing the fields. This will do for the example, for a real
application with differnt kinds of fields Magritte descriptions are much more suitable.

[[[label=partyFields|caption=Array of fields|language=Smalltalk 
DOParty class >>fields
	^self subclassResponsibility 
	
DOCompany class >>fields
	^#(#companyName)
	
DOPerson class >>fields
	^#(#firstName #lastName)	
]]]

Now we can initialize the widgets. ==instantiateModels== expects pairs of field names and field types
and adds them to the widgets dictionary.
They are then laid out in one column, given some default values and added in focus order.

[[[label=editorWidgets|caption=Use the fields to build the widgets needed|language=Smalltalk 
DOPartyEditor>>initializeWidgets
	|models|
	models := OrderedCollection new.
	partyClass fields do: [ :field | models add: field; add: #TextInputFieldModel ].
	self instantiateModels: models.
	
	layout := SpecLayout composed
		newColumn: [ :col |
			partyClass fields do: [ :field | 
				col add: field height: self class inputTextHeight]];
		yourself.
		
	 self widgets keysAndValuesDo:  [ :key :value |
		value autoAccept: true;
			entryCompletion:nil;
			ghostText: key.
		self focusOrder add: value] 
]]]

The last thing needed is to calculate how large the window should be. It is going to be used 
as a dialog with ok and cancel that take up a height of about three input fields. 

[[[label=editorExtent|caption=Different kinds of party have different number of fields|language=Smalltalk 
DOPartyEditor>>initialExtent
	^ 300@(self class inputTextHeight*(3+partyClass fields size))
]]]

Now we can test the editor with ==(DOPartyEditor on: DOCompany) openDialogWithSpec== and ==(DOPartyEditor on: DOPerson) openDialogWithSpec==

!! The address book

We can now make the address book with a search field and buttons to add persons and companies.
Add a class ==DOPartiesList==

[[[label=partiesList|caption=Create a class to show the list of parties|language=Smalltalk 
ComposableModel subclass: #DOPartiesList
	instanceVariableNames: 'search addPerson addCompany list'
	classVariableNames: ''
	package: 'Domain-Parties'
]]]

As soon as something is typed in the search field, the list should show the list of parties 
having a fullName containing the search term, ignoring case. 

[[[label=refreshList|caption=Show only the items matching the search|language=Smalltalk 
DOPartiesList>>refreshItems
	|searchString|
	searchString := search text asLowercase.
	list 
		items: (DOPartiesModel default parties select: [: each | 
			searchString isEmpty or: [each fullName asLowercase includesSubstring: searchString]]);
		displayBlock: [ :each |  each fullName].
]]]

We can now create the widgets and the default layout (class side)

[[[label=partiesListWidgets|caption=The widgets for the parties list|language=Smalltalk 
DOPartiesList>>initializeWidgets
	search := self newTextInput.
	search autoAccept: true;
		entryCompletion:nil;
		ghostText: 'Search'.
	addPerson := self newButton.
	addPerson label: '+Person'.
	addCompany := self newButton.
	addCompany label: '+Company'.
	list := self newList.
	
	self refreshItems.
	self focusOrder 
		add: search;
		add: addPerson;
		add: addCompany;
		add: list.
]]]

[[[label=partiesListWidgets|caption=The widgets for the parties list|language=Smalltalk 	
DOPartiesList class>>defaultSpec
	<spec: #default>
		
	^SpecLayout composed
		newColumn: [ :col |
				col newRow: [:row |
					row add: #search;
						add: #addPerson;
						add: #addCompany]
					height: ComposableModel toolbarHeight;  
					add: #list];
		yourself
]]]

When the user clicks on the ok button of the party editor, we need to create an instance of the right subclass, read the field values out of the editor and assign them to the attributes of the new instance. We do that using meta-programming (==perform:== and ==perform:with:==). 
Then we add the instance to the model and need to refresh the list. Add a method setting the ==okAction== block of the editor. 

[[[label=addAParty|caption=Adding a party|language=Smalltalk 
DOPartyList>>addPartyBlockIn: anEditor
	anEditor okAction: [ |party|
		party := anEditor model partyClass new.
		anEditor model partyClass fields do: [ :field |
			party perform: (field asMutator) with: (anEditor model perform: field) text ].
		DOPartiesModel default parties add: party.
		self refreshItems ]
]]]

Now we can initialize the presenter

[[[label=partiesListPresenter|caption=Behaviour of the parties list|language=Smalltalk 
DOPartyList>>initializePresenter
	search whenTextChanged: [ :class | self refreshItems  ].
	
	addPerson action: [  |edit|
		edit := (DOPartyEditor on:DOPerson) openDialogWithSpec.
		self addPartyBlockIn: edit].
	addCompany action: [  |edit|
		edit := (DOPartyEditor on: DOCompany) openDialogWithSpec.
		self addPartyBlockIn: edit ].
]]]
Don't forget the accessors
[[[label=partiesListAccessors|caption=Accessors|language=Smalltalk 
DOPartyList>>addCompany
	^addCompany
	
DOPartyList>>addPerson
	^addPerson
	
DOPartyList>>items: aCollection
	list items: aCollection
	
DOPartyList>>list 
	^list

DOPartyList>>search
	^search
]]]

protocol

[[[label=partiesListProtocol|caption=Protocol|language=Smalltalk 
DOPartyList>>resetSelection
	list resetSelection 
	
DOPartyList>>title
	^ 'Parties'
]]]
and protocol-events

[[[label=partiesListProtocolEvents|caption=Protocol events|language=Smalltalk 
DOPartyList>>whenAddCompanyClicked: aBlock 
	addCompany whenActionPerformedDo: aBlock
	
DOPartyList>>whenAddPersonClicked: aBlock 
	addPerson whenActionPerformedDo: aBlock
	
DOPartyList>>whenSelectedItemChanged: aBlock 
	list whenSelectedItemChanged: aBlock

]]]
This can be tested with ==DOPartiesList new openWithSpec==

!! Editing Parties
A next step is the editing of existing instances. In the ==DOPartiesList==, we need to use a ==NewListModel== instead of the ==ListModel==, as that understands doubleClick actions. 

[[[label=editingChanges|caption=Replace list by newlist|language=Smalltalk 
DOPartiesList>>initializeWidgets 
-	list := self newList. 
+	list := self instantiate: NewListModel. 
]]]

To edit a party, we modify ==addPartyBlockIn: anEditor== to create ==editParty:in:==. 
We set the data values and the title. In the okAction we don't have to add the party. 

[[[label=editAParty|caption=Edit instead of add|language=Smalltalk 
DOPartiesList>>editParty: aParty in: anEditor 
        aParty class fields do: [ :field | 
                (anEditor model perform: field) text: (aParty perform: field) ]. 

        anEditor title: 'Edit ',aParty fullName. 

        anEditor okAction: [ 
                anEditor model partyClass fields do: [ :field | 
                        aParty perform: field asMutator with: (anEditor model perform: field) text ]. 
                self refreshItems ]. 
]]]

In initializePresenter, we can then add an edit action. The list currently needs 
to know that it should handle doubleClicks, and then call a partyeditor 

[[[label=editingBehaviour|caption=Add a doubleclick action |language=Smalltalk 
DOPartiesList>>initializePresenter 
+	list handlesDoubleClick: true. 
+	list doubleClickAction: [ |party edit| 
+		party := list selectedItem. 
+		edit := (DOPartyEditor on:  party class) openDialogWithSpec. 
+		self editParty: party in: edit] 
]]]

