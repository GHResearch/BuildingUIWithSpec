{
	"metadata" : {
		"title" : "Dynamic Spec"
	}
}
@cha_dynamic_spec

@@todo JF saying nothing about the ==needFullRebuild:== method.

Up until now we have seen user interfaces that are static: Once the UI is opened, the widgets are never changed and the layout of the UI is never changed. Also, when writing the code we know exactly which widgets, and how many of them, to use. There are however cases where user interfaces need to be more dynamic, for example adding and removing widgets depending on user input, which requires a re-layout of (part of) the user interface, or showing multiple custom widgets, the number of which depends on the underlying data being shown. Spec also provides support for these situations thanks to its dynamic features.

In this chapter we show three dynamic features of Spec. Firstly we present how to dynamically change a UI that is already open. Secondly we give an example of how to defer to UI opening time the choice of widgets to show (instead of hardcoding this when writing the UI). Thirdly we script a complete UI from within one (big) block of code. 

!! Dynamically changing an already opened UI

[[[
ComposableModel subclass: #DynamicViewer
	instanceVariableNames: 'list view button state'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'
]]]

[[[
DynamicViewer >> extent
	^ 400@350
]]]

[[[
DynamicViewer >> items: aCollection.
	list items: aCollection
]]]

[[[
DynamicViewer >> initializeWidgets
	list := self newList.
	list displayBlock: [ :item | item printString contractTo: 15 ].
	
	button := self newButton.
	button label: 'Change!'.
	state := $v.
		
	view := self defaultView.
]]]

[[[
DynamicViewer >> defaultView
	| cm |
	cm := self newLabel.
	cm label: 'Select something from the list please.'.
	^cm
]]]


[[[
DynamicViewer class >> verticalSpec
	<spec: #default>
	^ SpecColumnLayout composed
		newRow: [ :r |
			r newColumn: [:c | c add: #list] left: 0 right: 0.7.
			r newColumn: [:c | c add: #view] left: 0.32 right: 0];
		newRow: [ :r | r add: #button ] height: self toolbarHeight;
      yourself.
]]]

[[[
DynamicViewer class >> horizontalSpec
	^ SpecColumnLayout composed
      newRow: [:r | r add: #list] top: 0 bottom: 0.7;
		newRow: [:r | r add: #view] top: 0.32 bottom: 0.02;
		newRow: [:r | r add: #button] height: self toolbarHeight;
      yourself.
]]]

[[[
DynamicViewer >> initializePresenter
	button action: [
		state := (state = $v)	ifTrue: [ $h ] ifFalse: [ $v ].
		self needRebuild: false.
		self buildWithSpecLayout: self currentSpec.
		].
]]]

[[[
DynamicViewer >> currentSpec.
	^ state = $v
		ifTrue: [ self class verticalSpec ]
		ifFalse: [ self class horizontalSpec ]
]]]

[[[
DynamicViewer >> initializePresenter
	button action: [
		state := (state = $v)	ifTrue: [ $h ] ifFalse: [ $v ].
		self needRebuild: false.
		self buildWithSpecLayout: self currentSpec.
		].

	list whenSelectedItemChanged: [ :new |
			view := self widgetFor: new.
			self needRebuild: false.
			self buildWithSpecLayout: self currentSpec.
		].
]]]

[[[
DynamicViewer >> widgetFor: aDatum
	| cm |
	aDatum isNil ifTrue: [ ^self defaultView ].
	aDatum isForm ifTrue: [ 
		cm := self newImage.
		cm image: aDatum.
		^cm ].
	aDatum isArray ifTrue: [ 
		cm := self newList.
		cm items: aDatum.
		^cm].
	
	"default case"
	cm := self newText.
	cm text: aDatum asString.
	^cm
]]]

@@note The code for ==widgetFor:== does not follow good OO practices. In the context of this chapter we choose to write ugly code like this to make the example more self-contained. However, any student of ours caught writing code like this will be invited to our office for a long conversation.


[[[
| viewer |
 viewer := DynamicViewer new.
 viewer items: {
	42 .
	'Everberg' . 
	#thumbsUp asIcon . 
	#(SGO CDG ZYR BRU) . 
	(OrderedCollection withAllSubclasses collect:[: cls | cls comment]) asArray}.
 viewer openWithSpec.
]]]

!! Dynamically populating a UI with widgets

[[[
DynamicComposableModel subclass: #DynamicArrayViewer
	instanceVariableNames: 'collection label'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'
]]]

[[[
DynamicArrayViewer >> initializeWidgets
	
	label := self newLabel.
	label label: 'An array with ',collection size asString, ' elements:'.
		
	1 to: collection size do: [ :count | | model |
		model := self newText.
		model text: (collection at: count) asString.
		self assign: model to: ('txt_',count asString) asSymbol .
		 ]
]]]

@@note JF talk in a note about the accessors so you can also do stuff in initializePresenter

[[[
DynamicArrayViewer >> layout
	"either set the layout with an accessor or override layout getter"
	| col |
	col := SpecColumnLayout composed.
	col add: #label.
	1 to: collection size do: [:count|
		col add: ('txt_',count asString) asSymbol ].
	
	^col 
]]]

[[[
DynamicArrayViewer class >> on: aCollection
	| inst |
	inst := self basicNew.
	inst collection: aCollection.
	inst initialize.
	^inst.
]]]

[[[
(DynamicArrayViewer on: (OrderedCollection withAllSubclasses collect:[: cls | cls comment])) openWithSpec.
]]]


!! Hacking together a UI in the Playground

Thanks to the ==DynamicComposableModel==, Spec also allows for a more scripting-like development style, where the entire UI is defined in one giant piece of code, typically built incrementally. This may be useful, e.g. for `quick and dirty' prototyping where you want to omit the creation of a class for the UI as well as the definition of multiple methods. In this section we show how we can hack together a simple UI, scripting style, from within the Playground.

The UI we build here is a simple example showing a number and two buttons, one to increment the number and one to decrement it. This example is adapted from code present in the Pharo 5 image: ==DynamicSpecExample >> openOnInteger== by Torsten Bergmann, for which we give our thanks.

We start our example code by instantiating a ==DynamicComposableModel== and setting the title and size of the window for our UI by using the ==title:== and ==extent:== methods (see Chapter *@cha_managing_windows*). Note that the local variable ==num== will hold the number shown in the UI.

[[[
	| ui num |
	
	num := 0.
	ui := DynamicComposableModel new.
	ui title: 'I am dynamic'.
	ui extent: 250@70.
]]]

We then add the widgets to the UI, using the ==instantiateModels:== method. This method takes as argument a collection of pairs. The first element of the pair is the name of the widget, i.e. the name of the instance variable if this would be a normal, static, UI. The second element of the pair is a subclass of ==ComposableModel==, determining the type of the widget.

[[[	
	ui instantiateModels: #( 
		text LabelModel
		plus ButtonModel
		minus ButtonModel ).
]]]

Hence this UI will hold a ==text== widget, which is a ==LabelModel== instance, as well as two ==ButtonModel== widgets, in ==plus== and ==minus==, respectively. Fundamentally, the code above is the only change with respect to normal UI development. The rest of UI coding happens almost identically as before.

With the widgets defined and instantiated, we can now configure them, as we would do in a normal ==initializeWidgets== or ==initializePresenter== method:

[[[
	ui text label: num asString.
	
	ui minus 
		label: '-';
		state: false;
		action: 	[ 
			num := num -1.
			ui text label: num asString ].

	ui plus 
		label: '+';
		state: false;
		action: 	[ 
			num := num +1.
			ui text label: num asString ].
]]]

The last thing we need to do is to give the UI a layout. This is done by calling the ==layout:== method, giving it an instance of a ==SpecLayout== that specifies the layout. The UI can then be opened and is fully functional.

[[[
	ui layout := (SpecLayout composed
		newColumn: [ :c |
			c
				add: #text height: 25;
				newRow: [ :r | r add: #minus ; addSplitter; add: #plus ] height: 25 ];
		yourself).
				
	ui openWithSpec.
]]]

@@note When doing this you are ignoring all the code writing and management facilities that Pharo has to offer (e.g. the browser) and not cleanly separating the different responsibilities of the code of the UI. In other words, this is truly a quick and dirty way to hack together a user interface that should really not make it to production.

@@note JF Everything below this line is old stuff that should disappear

!! ProtocolBrowser dynamic Version

Having an user interface with a well known number of sub widgets and a static layout is not always sufficient.
A user interface is often more than just that, for example here are two situations where more is needed:
First, when the layout of the user interface needs to be changed at runtime to match the execution context of the software.
Second, sub widgets are added or removed at runtime and therefore the programmer needs to be able to parametrize those new sub widgets on the fly.

''Spec'' also provides support for such dynamic user interfaces.
In this section we show how to use ''Spec'' in these situations.

First, we talk about making dynamic modifications of the layout of widgets, and second we discuss the dynamic adding and removing of subwidgets.
Third and last we show how the dynamic features can be used to quickly prototype a user interface.



!!! Dynamic modification of the layout

Changing the layout of widgets at runtime is straightforward, as we will see here.

Such changes basically consist of three steps:
- First, create the new layout.
- Second, the ==needRebuild== flag is set to ==false== to prohibit the creation of a new UI element (and reuse the existing one).
- Third, the rebuilding of the user interface is performed.

One widget can also keep the UI elements of its sub widgets which do not need to be rebuilt.
The message ==needRebuild: false== needs to be sent to any of those sub widgets.

For example, if a model comprising a ''button'' and a ''list'' just wants to rearrange the position of these UI elements, there is no need to rebuild them. As shown in the example *@ex_needRebuild*

[[[label=ex_needRebuild|caption=How to need rebuild sub widgets|language=Smalltalk
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false.
	theButton needRebuild: false.
	theList needRebuild: false.
	self buildWithSpecLayout: newLayout.
]]]



!!! Dynamic adding and removal of subwidgets

If a user interface needs a varying number of subwidgets, the amount of which cannot be established at compilation time, then another approach is needed.
In this scenario, ==DynamicComposableModel== is the model that needs to be subclassed, as this class provides support for the required kind of dynamic behavior.

Amongst others, this class adds the method ==assign:to:==, which takes a model instance as a first argument, and a unique symbol as a second argument.
This method is used to assign an already instantiated model as sub widget, instead of the method ==instantiateModels:== that takes a class name as argument and instantiates a new model.

When using ==DynamicComposableModel==, the instantiation of the sub widgets is a bit different from normal use.
In the ==instantiateWidgets== method, instead of instantiating each widget separately, ==instantiateModels:== should be used to instantiate them.
This method takes as argument an array of pairs, where each pair is composed of the unique name of the widget as key, and the name of the widget class as value.
This allows for a widget to be accessed by sending a message whose selector is the widget name to the model.

By example, if a widget named ==button== is created, then this widget can be accessed by calling ==self button== as shown in the example *@ex_dynamic_creation*.

[[[label=ex_dynamic_creation|caption=Dynamic creation of a widget|language=Smalltalk
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

!!! Examples: Prototyping a UI

Thanks to the capability of ''Spec'' to dynamically instantiate widgets, it is also possible to prototype a user interface from within any workspace.
The following examples show how ''Spec'' can be used to quickly prototype a user interace.

The first example explains how to design by prototyping a user interface.
The second example introduces the composition of dynamic models.


The result can be seen in Figure *@fig_popup*.


!!!! Composing dynamic models

This exemple shows in three parts how to buid a simple code browser.

First a simple list widget is created displaying all the subclasses of AstractWidgetModel.

Then the list widget is reused to build a viewer widget displaying the protocol methods of the selected class.

Finally the last widget is defined with the previously created viewer.
In addition, a text zone is added to show the selected methods source code.

The final result looks like the Figure *@fig_browser*.

[[[
| dynamicWidgetClassList dynamicProtocolViewer dynamicProtoclBrowser |
	dynamicWidgetClassList := DynamicComposableModel new.
	dynamicWidgetClassList instantiateModels: #(#list #ListModel).
	dynamicWidgetClassList list items: (AbstractWidgetModel allSubclasses sorted: [ :a :b | a name < b name ]).
	dynamicWidgetClassList
		layout:
			(SpecLayout composed
				add: #list;
				yourself).
	dynamicWidgetClassList openWithSpec.
	dynamicProtocolViewer := DynamicComposableModel new.
	dynamicProtocolViewer assign: dynamicWidgetClassList to: #classes.
	dynamicProtocolViewer instantiateModels: #(#methods #ListModel).
	dynamicWidgetClassList list
		whenSelectedItemChanged: [ :item |
			item
				ifNil: [ dynamicProtocolViewer methods items: #() ]
				ifNotNil: [ dynamicProtocolViewer methods items: (item selectorsInProtocol: 'api') sorted ] ].
	dynamicProtocolViewer
		layout:
			(SpecLayout composed
				newRow: [ :r |
					r
						add: #classes;
						add: #methods ];
				yourself).
	dynamicProtocolViewer openWithSpec.
	dynamicProtoclBrowser := DynamicComposableModel new.
	dynamicProtoclBrowser assign: dynamicProtocolViewer to: #top.
	dynamicProtoclBrowser instantiateModels: #(#text #TextModel).
	dynamicProtocolViewer methods
		whenSelectedItemChanged: [ :selector |
			selector
				ifNil: [ dynamicProtoclBrowser text text: '' ]
				ifNotNil: [ dynamicProtoclBrowser text text: (dynamicWidgetClassList list selectedItem >> selector) sourceCode ] ].
	dynamicProtoclBrowser
		layout:
			(SpecLayout composed
				newColumn: [ :c |
					c
						add: #top;
						add: #text ];
				yourself).
	dynamicProtoclBrowser openWithSpec.
	dynamicProtoclBrowser title: 'Protocol browser'
]]]

+Prototype of Protocol Browser>file://figures/Dyn_Protocol_Browser.png|width=50|label=fig_browser+
