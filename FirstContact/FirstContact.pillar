! First Contact With Examples
@chap_first_contact

This chapter presents Spec over a list of examples that highlight some characteristics of Spec. 
It will guide you through examples of increasing complexity. 

!! ListModel

We start with some example of lists: list with background colored item and icons. 

!!! Registered Colors in background

Here is an example of a ==ListModel== with elements having different colors. 
We want to that each element (displaying the name of the messsage to create a color) has such color as background as shown in Figure *@fig_modified_background*. 
The following code shows how to build a list widget using a ==ListModel== containing all registered color names.

[[[label=ex_registered_colors_list|caption=List of registered colors|language=Smalltalk
	| registeredColorsList |
	registeredColorsList := ListModel new.
	registeredColorsList
		items: Color registeredColorNames;
		backgroundColorBlock: [ :item | Color named: item ];
		title: 'Registered colors'.
	registeredColorsList openWithSpec
]]]

+ListModel with modified background colors.>file://figures/RegisteredColors.png|width=50|label=fig_modified_background+

Here we see the following messages that are part of the ==ListModel== API. 

- Message ==items:== sets the elements of the list. 
- Message ==backgroundColorBlock:== specifies a block that is executed to determine the background color of the current element.  It takes a block with a single parameter that is the item concerned by the background color.
- Message ==title:== sets the title of the window containing the list.

Finally this example shows that the message ==openWithSpec== open and place the resulting widget on the screen. 

!!! List of icons

In this example, we are going to build a list containing icons of the current theme and their respective selector using a subclass of ListModel : IconListModel.

==#displayBlock:== wrap your domain specific items and should return something that can be displayed in a list, like a String or a Text.

[[[label=ex_icon_list|caption=Icons List|language=Smalltalk
	| iconList |
	iconList := IconListModel new.
	iconList
		items: Smalltalk ui icons allIconNames asSortedCollection;
		displayBlock: [ :selector | selector asString ];
		sortingBlock: [ :selectorA :selectorB | selectorA < selectorB ];
		icons: [ :each | Smalltalk ui icons iconNamed: each ];
		title: 'Availiable icons for the current theme.'.
	iconList openWithSpec
]]]

+A first widget with Spec.>file://figures/FirstExample.png|width=50|label=fig_first_example+




!!! Shortcut Instanciation

In the previous example, we explicitly referred to the class ==ListModel==. Note that the 
superclass ==ComposableModel== provides shorcut methods for the most used basics widget.
Its definition for ==newList== is the following one :

[[[caption=Implementation of ComposableModel>>newList|language=Smalltalk
ComposableModel >> newList
	^ self instantiate: ListModel
]]]

Similarly ==ComposableModel== defines message for ==newButton==, ==newCheckBox==, ==newDropList==,...
Note that the interest of having such methods is unclear and can be revisited in future versions of Spec. 



!! ButtonModel and LabelModel

In that example, we create a widget looking like a calculator with only three digits buttons and without operations.
That example is a bit more complex and we have to create a class from which it will be instantiated. That class must be a subclass of ==ComposableModel==.

[[[label=ex_speccalc_classcreation|caption=Creation of the class|language=Smalltalk
ComposableModel subclass: #SpecCalc
	instanceVariableNames: 'calcScreen button0 button1 button2'
	classVariableNames: ''
	package: 'Specalc'
]]]

Basically, at the instance side of the class we will declare the widgets that we will be using, some aspects of these widgets like labels, actions, states, and the logic of the application and the glue between these widgets. On the other hand, at class side, we will set up the basic design of our GUI -how the widgets are laid out- and its title.

Summarizing:
- instance side: widget instantiation along with actions performed by these and application logic.
- class side: widget layout i.e., how all our widgets will be laid out in a window.

A subclass of ==ComposableModel== have responsibility to define the ==initializeWidgets== method and defaultSpec class method. In which we will instanciate buttons and the screen with methods provided by the superclass.
Then, we define buttons with the label which will be display on them and the block to perform when they are acliked.
Finally, its a good practice to define the focus order, it use for keyboard navigation.


[[[label=ex_speccalc_initializewidgets|caption=code of Specalc>>initializeWidgets|language=Smalltalk|
Specalc >> initializeWidgets
	calcScreen := self newLabel.
	button0 := self newButton.
	button1 := self newButton.
	button2 := self newButton.
	button0
		label: '0';
		action: [ self addAtScreen: button0 label ].
	button1
		label: '1';
		action: [ self addAtScreen: button1 label ].
	button2
		label: '2';
		action: [ self addAtScreen: button2 label ].
	self focusOrder
		add: button0;
		add: button1;
		add: button2
]]]

We must create the accessors and the method ==Specalc>>addAtScreen:==, the methods ==asNumber asString== are used to remove not significant zeros. We set the label representing a screen with the concatenation between its previous label and the label of the button.

[[[label=ex_speccalc_addatscreen|caption=code of Specalc>>addAtScreen:|language=Smalltalk|
Specalc>>addAtScreen: aLabel
	calcScreen label: (calcScreen label , aLabel) asNumber asString
]]]

In the following class side method ==defaultSpec==, the ==height:== is important to let enought place at the screen. Pay attention the argument of the ==add:== message are accessors refered by their symbols.

[[[label=ex_speccalc_defaultSpec|caption=code of Specalc class>>defaultSpec|language=Smalltalk|
Specalc >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newRow: [ :row | row add: #calcScreen ];
		newRow: [ :row | 
			row
				add: #button0;
				add: #button1;
				add: #button2 ]
			height: 50;
		yourself
]]]

The following ==title== method change the title of the window.

[[[caption=code of Specalc class>>title|language=Smalltalk|
Specalc>>title
	^ 'SpecCalculator'
]]]

Now, executing the code

[[[language=Smalltalk
SpecCalc new openWithSpec
]]]

and click the buttons : 0, 0, 1, 0, 2 should give the figure *fig_SpecCalc_FirstWidget*.

+First SpecCalc widget.>file://figures/SpecCalc_FirstWidget.png|width=50|label=fig_SpecCalc_FirstWidget+


!!! Declaring a Different Layout

We can declare a different layout for the same model. 

[[[label=ex_speccalc_defaultSpec|caption=code of Specalc class>>defaultSpec|language=Smalltalk|
Specalc >> bottomSpec
	<spec: #bottomSpec>
	^ SpecLayout composed
		newRow: [ :row | row add: #calcScreen ];
		newRow: [ :row | 
			row
				add: #button0;
				add: #button1;
				add: #button2 ]
			height: 50;
		yourself
]]]

@@todo a verifier et expliquer <spec>

[[[language=Smalltalk
SpecCalc new openWithSpec: #bottomSpec
]]]


@@todo add textfield and may be some other widgets

@@todo little example with radio button M. Mrs .. and inputfield