! First Contact With Examples
@cha_first_contact

This chapter presents Spec over a list of examples that highlight some characteristics of Spec. 
It will guide you through examples of increasing complexity. 

!! ListModel

We start with some example of lists: list with background colored item and icons. 

!!! Registered Colors in background

Here is an example of a ==ListModel== with elements having different colors. 
We want to that each element (displaying the name of the messsage to create a color) has such color as background as shown in Figure *@fig_modified_background*. 
The following code shows how to build a list widget using a ==ListModel== containing all registered color names.

[[[label=ex_registered_colors_list|caption=List of registered colors|language=Smalltalk
	| registeredColorsList |
	registeredColorsList := ListModel new.
	registeredColorsList
		items: Color registeredColorNames;
		backgroundColorBlock: [ :item | Color named: item ];
		title: 'Registered colors'.
	registeredColorsList openWithSpec
]]]

+ListModel with modified background colors.>file://figures/RegisteredColors.png|width=50|label=fig_modified_background+

Here we see the following messages that are part of the ==ListModel== API. 

- Message ==items:== sets the elements of the list. 
- Message ==backgroundColorBlock:== specifies a block that is executed to determine the background color of the current element.  It takes a block with a single parameter that is the item concerned by the background color.
- Message ==title:== sets the title of the window containing the list.

Finally this example shows that the message ==openWithSpec== open and place the resulting widget on the screen. 

!!! List of icons

In this example, we are going to build a list containing icons of the current theme and their respective selector using a subclass of ListModel : IconListModel.

==#displayBlock:== wrap your domain specific items and should return something that can be displayed in a list, like a String or a Text.

[[[label=ex_icon_list|caption=Icons List|language=Smalltalk
	| iconList |
	iconList := IconListModel new.
	iconList
		items: Smalltalk ui icons allIconNames asSortedCollection;
		displayBlock: [ :selector | selector asString ];
		sortingBlock: [ :selectorA :selectorB | selectorA < selectorB ];
		icons: [ :each | Smalltalk ui icons iconNamed: each ];
		title: 'Availiable icons for the current theme.'.
	iconList openWithSpec
]]]

+A List of Icons.>file://figures/IconList.png|width=50|label=fig_IconList+


!!! Shortcut Instanciation

In the previous example, we explicitly referred to the class ==ListModel==. Note that the 
superclass ==ComposableModel== provides shorcut methods for the most used basics widget.
Its definition for ==newList== is the following one :

[[[caption=Implementation of ComposableModel>>newList|language=Smalltalk
ComposableModel >> newList
	^ self instantiate: ListModel
]]]

Similarly ==ComposableModel== defines message for ==newButton==, ==newCheckBox==, ==newDropList==,...
Note that the interest of having such methods is unclear and can be revisited in future versions of Spec. 



!! ButtonModel and LabelModel

This example show a create a widget and how to control basically the window and the layout used for the render.

!!! Create the widget

That example is a bit more complex and we have to create a class from which it will be instantiated. That class must be a subclass of ==ComposableModel==.

[[[label=ex_SpecHappy_classcreation|caption=Creation of the class|language=Smalltalk
ComposableModel subclass: #SpecHappy
	instanceVariableNames: 'calcScreen button0 button1 button2'
	classVariableNames: ''
	package: 'SpecHappy'
]]]

Basically, at the instance side of the class we will declare the widgets that we will be using, some aspects of these widgets like labels, actions, states, and the logic of the application and the glue between these widgets. On the other hand, at class side, we will set up the basic design of our GUI -how the widgets are laid out- and its title.

Summarizing:
- instance side: widget instantiation along with actions performed by these and application logic.
- class side: widget layout i.e., how all our widgets will be laid out in a window.

A subclass of ==ComposableModel== have responsibility to define the ==initializeWidgets== method and defaultSpec class method. In which we will instanciate buttons and the screen with methods provided by the superclass.

Then, we define buttons :
- ==label:== to define the label which will be display on them
- ==action:== to define the block to perform when they are acliked
- ==icon:== to define an icon which will be display near the label
Note that ==label:== is used to define the default text on the screen. Then, it used by buttons to change the text on the screen.

Finally, its a good practice to define the focus order, it use for keyboard navigation.


[[[label=ex_SpecHappy_initializewidgets|caption=code of SpecHappy>>initializeWidgets|language=Smalltalk|
SpecHappy >> initializeWidgets

	"widgets instanciation"
	screen := self newLabel.
	buttonHappy := self newButton.
	buttonNeutral := self newButton.
	buttonBad := self newButton.

	"widgets configuration specification"
	screen label: 'Tell us ?'.
	buttonHappy
		label: 'Happy';
		action: [ screen label: buttonHappy label ];
		icon: (Smalltalk ui icons iconNamed: #thumbsUp).
	buttonNeutral
		label: 'Neutral';
		action: [ screen label: buttonNeutral label ];
		icon: (Smalltalk ui icons iconNamed: #user).
	buttonBad
		label: 'Bad';
		action: [ screen label: buttonBad label ];
		icon: (Smalltalk ui icons iconNamed: #thumbsDown).

	"specification of order of focus"
	self focusOrder
		add: buttonHappy;
		add: buttonNeutral;
		add: buttonBad
]]]


In the following class side method ==defaultSpec==, the ==height:== is important to let enought place at the screen. Pay attention the argument of the ==add:== message are accessors refered by their symbols.

[[[label=ex_spechappy_defaultspec|caption=Code of SpecHappy class >> defaultSpec|language=Smalltalk|
SpecHappy >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newRow: [ :row | row add: #screen ];
		newRow: [ :row | 
			row
				add: #buttonHappy;
				add: #buttonNeutral;
				add: #buttonBad ]
			height: 50;
		yourself
]]]

Overide the ==title== method in the subclass change the title of the window, like the call at the ==title:== method.

[[[caption=code of SpecHappy class >> title|language=Smalltalk|
SpecHappy>>title
	^ 'Customers satisfaction'
]]]

!!! The methods to open the window

==ComposableModel== provides methods to open a window containing a widget.
==openWithSpec== is the most basic.
Here, it will use the layout provide by the method containing the pragma "<spec: #default>" and should give the figure *@fig_Customers_Basic*.
Further information about the layout lookup are given in the Chapter *@cha_deeper_into_spec*

[[[language=Smalltalk
SpecHappy new openWithSpec
]]]

+Basic SpecHappy widget.>file://figures/Customers_Basic.png|width=50|label=fig_Customers_Basic+

Another method of ==ComposableModel==, ==openDialogWithSpec==, open the model in a dialog window, the following code should give the figure *@fig_Customers_Dialog*.

[[[language=Smalltalk
SpecHappy new openDialogWithSpec
]]]

+SpecHappy widget in a Dialog.>file://figures/Customers_Dialog.png|width=50|label=fig_Customers_Dialog+

!!! Declaring a Different Layout

Others methods of ==ComposableModel== let specify the layout to use, like ==openWithSpec:==.
So we can declare a different layout for the same model. 

[[[label=ex_spechappy_layout|caption=New Layout for SpecHappy |language=Smalltalk|
SpecHappy class >> layout
	<spec>
	^ SpecLayout composed
		newColumn: [ :column | 
			column
				add: #buttonHappy;
				add: #buttonNeutral;
				add: #buttonBad ];
		newColumn: [ :column | column add: #screen ] width: 100;
		yourself
]]]

@@todo expliquer <spec>

[[[language=Smalltalk
SpecHappy new openWithSpec: #layout
]]]

+New Layout for SpecHappy widget.>file://figures/Customers_NewLayout.png|width=50|label=fig_Customers_NewLayout+

@@todo add textfield and may be some other widgets

@@todo little example with radio button M. Mrs .. and inputfield
