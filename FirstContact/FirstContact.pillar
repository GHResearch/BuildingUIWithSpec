! First Contact With Examples
@cha_first_contact


This chapter presents Spec over a list of examples that highlight some characteristics of Spec. 
It will guide you through examples of increasing complexity. 

!! ListModel

We start with some example of lists: list with background colored item and icons. 

!!! Registered Colors in background

Here is an example of a ==ListModel== with elements having different colors. 
We want to that each element (displaying the name of the messsage to create a color) has such color as background as shown in Figure *@fig_modified_background*. 
The following code shows how to build a list widget using a ==ListModel== containing all registered color names.

[[[label=ex_registered_colors_list|caption=List of registered colors|language=Smalltalk
	| registeredColorsList |
	registeredColorsList := ListModel new.
	registeredColorsList
		items: Color registeredColorNames;
		backgroundColorBlock: [ :item | Color named: item ];
		title: 'Registered colors'.
	registeredColorsList openWithSpec
]]]

+ListModel with modified background colors.>file://figures/RegisteredColors.png|width=50|label=fig_modified_background+

Here we see the following messages that are part of the ==ListModel== API. 

- Message ==items:== sets the elements of the list. 
- Message ==backgroundColorBlock:== specifies a block that is executed to determine the background color of the current element.  It takes a block with a single parameter that is the item concerned by the background color.
- Message ==title:== sets the title of the window containing the list.

Finally this example shows that the message ==openWithSpec== open and place the resulting widget on the screen. 

!!! List of icons

In this example, we are going to build a list containing icons of the current theme and their respective selector using a subclass of ListModel : IconListModel.

==#displayBlock:== wrap your domain specific items and should return something that can be displayed in a list, like a String or a Text.

[[[label=ex_icon_list|caption=Icons List|language=Smalltalk
	| iconList |
	iconList := IconListModel new.
	iconList
		items: Smalltalk ui icons allIconNames asSortedCollection;
		displayBlock: [ :selector | selector asString ];
		sortingBlock: [ :selectorA :selectorB | selectorA < selectorB ];
		icons: [ :each | Smalltalk ui icons iconNamed: each ];
		title: 'Availiable icons for the current theme.'.
	iconList openWithSpec
]]]

+A List of Icons.>file://figures/IconList.png|width=50|label=fig_IconList+


!!! Shortcut Instanciation

In the previous example, we explicitly referred to the class ==ListModel==. Note that the 
superclass ==ComposableModel== provides shorcut methods for the most used basics widget.
Its definition for ==newList== is the following one :

[[[caption=Implementation of ComposableModel>>newList|language=Smalltalk
ComposableModel >> newList
	^ self instantiate: ListModel
]]]

Similarly ==ComposableModel== defines message for ==newButton==, ==newCheckBox==, ==newDropList==,...
Note that the interest of having such methods is unclear and can be revisited in future versions of Spec. 



!! ButtonModel and LabelModel

This example show a create a widget and how to basically control the window and the layout used for the render.

!!! Create the widget

That example is a bit more complex and we have to create a class from which it will be instantiated. That class must be a subclass of ==ComposableModel==.

[[[label=ex_SpecHappy_classcreation|caption=Creation of the class|language=Smalltalk
ComposableModel subclass: #SpecHappy
	instanceVariableNames: 'calcScreen button0 button1 button2'
	classVariableNames: ''
	package: 'SpecHappy'
]]]

Basically, at the instance side of the class we will declare the widgets that we will be using, some aspects of these widgets like labels, actions, states, and the logic of the application and the glue between these widgets. On the other hand, at class side, we will set up the basic design of our GUI -how the widgets are laid out- and its title.

Summarizing:
- instance side: widget instantiation along with actions performed by these and application logic.
- class side: widget layout i.e., how all our widgets will be laid out in a window.

A subclass of ==ComposableModel== have responsibility to define the ==initializeWidgets== method and defaultSpec class method. In which we will instanciate buttons and the screen with methods provided by the superclass.

Then, we define buttons :
- Message ==label:== define the label which will be display on them
- Message ==action:== define the block to perform when they are acliked
- Message ==icon:== define an icon which will be display near the label
Note that ==label:== is used to define the default text on the screen. Then, it used by buttons to change this text.

Finally, its a good practice to define the focus order, it use for keyboard navigation.


[[[label=ex_SpecHappy_initializewidgets|caption=code of SpecHappy>>initializeWidgets|language=Smalltalk|
SpecHappy >> initializeWidgets

	"widgets instanciation"
	screen := self newLabel.
	buttonHappy := self newButton.
	buttonNeutral := self newButton.
	buttonBad := self newButton.

	"widgets configuration specification"
	screen label: 'Tell us ?'.
	buttonHappy
		label: 'Happy';
		action: [ screen label: buttonHappy label ];
		icon: (Smalltalk ui icons iconNamed: #thumbsUp).
	buttonNeutral
		label: 'Neutral';
		action: [ screen label: buttonNeutral label ];
		icon: (Smalltalk ui icons iconNamed: #user).
	buttonBad
		label: 'Bad';
		action: [ screen label: buttonBad label ];
		icon: (Smalltalk ui icons iconNamed: #thumbsDown).

	"specification of order of focus"
	self focusOrder
		add: buttonHappy;
		add: buttonNeutral;
		add: buttonBad
]]]


In the following class side method ==defaultSpec==, the ==height:== is important to let enought place at the screen. Pay attention the argument of the ==add:== message are accessors refered by their symbols.

[[[label=ex_spechappy_defaultspec|caption=Code of SpecHappy class >> defaultSpec|language=Smalltalk|
SpecHappy >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newRow: [ :row | row add: #screen ];
		newRow: [ :row | 
			row
				add: #buttonHappy;
				add: #buttonNeutral;
				add: #buttonBad ]
			height: 50;
		yourself
]]]

!!! The methods to control the window

!!!! The ==title== method

Overide the ==title== method in the subclass change the title of the window, like the call at the ==title:== method.

[[[caption=code of SpecHappy class >> title|language=Smalltalk|
SpecHappy>>title
	^ 'Customers satisfaction'
]]]

!!!! The methods to instanciate the Window

@@todo may give more informations about modal

==ComposableModel== provides methods to open a window containing a widget.
==openWithSpec== is the most basic.
Here, it will use the layout provide by the method containing the pragma "<spec: #default>" and should give the figure *@fig_Customers_Basic*.
Further information about the layout lookup are given in the Chapter *@cha_deeper_into_spec*

[[[language=Smalltalk
SpecHappy new openWithSpec
]]]

+Basic SpecHappy widget.>file://figures/Customers_Basic.png|width=50|label=fig_Customers_Basic+

Another method of ==ComposableModel==, ==openDialogWithSpec==, open the model in a dialog window, the following code should give the figure *@fig_Customers_Dialog*.

[[[language=Smalltalk
SpecHappy new openDialogWithSpec
]]]

==ComposableModel== provide the accessor ==window== to access at the instance of the created window.

+SpecHappy widget in a Dialog.>file://figures/Customers_Dialog.png|width=50|label=fig_Customers_Dialog+


!!!! The ==initialExtent== method

@@todo explain the use of initialExtent

!!! Declaring a Different Layout

Others methods of ==ComposableModel== let specify the layout to use, like ==openWithSpec:==.
So we can declare a different layout for the same model. 

[[[label=ex_spechappy_layout|caption=New Layout for SpecHappy |language=Smalltalk|
SpecHappy class >> layout
	<spec>
	^ SpecLayout composed
		newColumn: [ :column | 
			column
				add: #buttonHappy;
				add: #buttonNeutral;
				add: #buttonBad ];
		newColumn: [ :column | column add: #screen ] width: 100;
		yourself
]]]

@@todo expliquer <spec>

[[[language=Smalltalk
SpecHappy new openWithSpec: #layout
]]]

+New Layout for SpecHappy widget.>file://figures/Customers_NewLayout.png|width=50|label=fig_Customers_NewLayout+


!! TextInputFieldModel and Dynamic Widget : The Pop up

% spirita : fixed example, temporary variables was renamed to prevent being confusing whith methods

This example shows how to design a popup window asking for an input, created dynamically.

!!! The code

The widget is an instance of a subclass of ==ComposableModel== named ==DynamicComposableModel== which specialize ==doesNotUnderstand:== so that we can use accessors to access dynamic elements.

@@todo must be checked but it seems impossible to define directly in a class (must use a static declaration).

[[[label=ex_popup|caption=A pop up created dynamically |language=Smalltalk|
	| popup |
	"Widgets instanciation"
	popup := DynamicComposableModel new
		instantiateModels: #(#inputLabel #LabelModel #inputText #TextInputFieldModel);
		extent: 300 @ 90;
		title: 'Choose your project';
		yourself.

	"Widgets configuration specification"
	popup inputLabel label: 'Packages :'.
	popup inputText
		autoAccept: true;
		entryCompletion: nil;
		ghostText: 'I am a ghostText';
		bindKeyCombination: Character cr toAction: [ popup window triggerOkAction ].

	"Specification of order of focus"
	popup focusOrder add: popup inputText.

	"Layout specifiation"
	popup layout:
		(SpecLayout composed
			newRow: [ :row | 
				row
					add: #inputLabel width: 75;
					add: #inputText ];
			yourself).

	"DialogWindowModel instanciation"
	popup openDialogWithSpec.

	"Specification of action when Ok is clicked."
	popup window okAction: [ Transcript show: popup inputText text ]
]]]


!!! The Messages

In Widgets instanciation :
- Message ==extent:== (provide by ==ComposableModel==) set the initial size of the widget.
- Message ==instantiateModels:== instanciates several models at once. It takes as argument an array of pairs, where each pair is composed of the unique name of the widget as key (here #inputLabel #inputText), and the name of the widget class to instanciate as value (here #LabelModel #TextInputFieldModel).

In Widgets configuration specification, the following messages are provide by the API of ==TextInputFieldModel== :
- Message ==autoAccept:==specify that the text field should automatically accept the text on each keystroke, such that it does not show the yellow 'edited' triangle on the top right.
- Message ==entryCompletion:== set an instance ==EntryCompletion== to treat the input.
- Message ==ghostText:== set simply the text of the ghost text
- Message ==bindKeyCombination:== set the  action for when ''Ok'' is clicked

Here, we must use the message ==layout:== to set the layout to use.

In Specification of action :
- Message ==okAction:== set a block to perform when the ''Ok'' button is clicked, here we simply print the content of the field in the Transcript.

+Prototype of a Popup>file://figures/Popup.png|width=50|label=fig_popup+


!!! Change the Toolbar

The default toolbar of the ==DialogWindowModel== has an ''Ok'' button and a ''Cancel'' button.
To get a widget with a single button ''Ok'', the toolbar to use should be defined explicitly using the accessor ==toolbar:==.

[[[label=ex_popup_newtoolbar|caption=A New Toolbar for te popup|language=Smalltalk|
	| popup toolbar |
	
	...
	
	"Specification of action when Ok is clicked."
"comment that line -> popup window okAction: [ Transcript show: popup inputText text ]"
	
	"Define the new Toolbar"
	newToolbar := OkToolbar new
		okAction: [ Transcript show: popup inputText text ];
		yourself.

	"Set the new Toolbar"
	popup window toolbar: newToolbar
]]]


+The Popup with a New Toolbar>file://figures/Popup_NewToolbar.png|width=50|label=fig_popup+


!! Found more Examples

@@todo fill it (eventually revisit it)

For the moment (and the writting) there are example in :
- Package Spec-Examples
- Help -> Spec -> Examples -> More Examples (link at the package)
- BuildingUIWithSpec/material/nameOfExample (extract from a previous version to be revisited)
- In BuildingUIWithSpec/material/Spec/SpecMaterial/ (M. Mrs)
- on StephanEggermont's repot (Ancestry and SpecGenerator)
- on the website http://spec.st/docs/home/ (drag 'n drop)
- on Spirita's sandbox
- AbstractWidgetModel subclasses (most part are in Spec-core widget) provide sometimes examples in their class side
- idem with ComposableModel subclasses in Spec-PolyWidgets

@@todo add textfield and may be some other widgets

@@todo little example with radio button M. Mrs .. and inputfield

