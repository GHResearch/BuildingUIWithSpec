! First Contact by examples
@chap_first_contact

!! ListModel

!!! Registeredd Colors in background

Here is an example of a ==ListModel== with elements having different colors. The following code shows how to build a ==ListModel== containing all registered color names.

==#items:== set the elements of the list. ==#title==

For each color, the element holding the name of the color has the color in background. To do this, the message ==#backgroundColorBlock:== is used. It takes a block with a single parameter that is the item concerned by the background color.

[[[label=ex_registered_colors_list|caption=List of registerred colors|language=Smalltalk|
	| registeredColorsList |
	registeredColorsList := ListModel new.
	registeredColorsList
		items: Color registeredColorNames;
		backgroundColorBlock: [ :item | Color named: item];
		title: 'Registered colors'.
	registeredColorsList openWithSpec
]]]

+ListModel with modified background colors.>file://figures/RegisteredColors.png|width=50|label=fig_modified_background+


!!! List of icons

In this example, we are going to build a list containing icons of the current theme and their respective selector using a subclass of ListModel : IconListModel.

==#displayBlock:== wrap your domain specific items and should return something that can be displayed in a list, like a String or a Text.

[[[label=ex_icon_list|caption=Icons List|language=Smalltalk|
	| iconList |
	iconList := IconListModel new.
	iconList
		items: Smalltalk ui icons allIconNames asSortedCollection;
		displayBlock: [ :selector | selector asString ];
		sortingBlock: [ :selectorA :selectorB | selectorA < selectorB ];
		icons: [ :each | Smalltalk ui icons iconNamed: each ];
		title: 'Availiable icons for the current theme.'.
	iconList openWithSpec
]]]

+A first widget with Spec.>file://figures/FirstExample.png|width=50|label=fig_first_example+

!! ButtonModel and LabelModel

In that example, we create a widget looking like a calculator with only three digits buttons and without operations.
That example is a bit more complex and we have to create a class from which it will be instantiated. That class must be a subclass of ==ComposableModel==.

[[[label=ex_speccalc_classcreation|caption=Creation of the class|language=Smalltalk|
ComposableModel subclass: #SpecCalc
	instanceVariableNames: 'calcScreen button0 button1 button2'
	classVariableNames: ''
	package: 'Specalc'
]]]

Basically, at the instance side of the class we will declare the widgets that we will be using, some aspects of these widgets like labels, actions, states, and the logic of the application and the glue between these widgets. On the other hand, at class side, we will set up the basic design of our GUI -how the widgets are laid out- and its title.

Summarizing:
- instance side: widget instantiation along with actions performed by these and application logic.
- class side: widget layout i.e., how all our widgets will be laid out in a window.

A subclass of ==ComposableModel== have responsibility to define the ==initializeWidgets== method and defaultSpec class method. In which we will instanciate buttons and the screen with methods provided by the superclass.
Then, we define buttons with the label which will be display on them and the block to perform when they are acliked.
Finally, its a good practice to define the focus order, it use for keyboard navigation.


[[[label=ex_speccalc_initializewidgets|caption=code of Specalc>>initializeWidgets|language=Smalltalk|
Specalc>>initializeWidgets
	calcScreen := self newLabel.
	button0 := self newButton.
	button1 := self newButton.
	button2 := self newButton.
	button0
		label: '0';
		action: [ self addAtScreen: button0 label ].
	button1
		label: '1';
		action: [ self addAtScreen: button1 label ].
	button2
		label: '2';
		action: [ self addAtScreen: button2 label ].
	self focusOrder
		add: button0;
		add: button1;
		add: button2
]]]

We must create the accessors and the method ==Specalc>>addAtScreen:==, the methods ==asNumber asString== are used to remove not significant zeros. We set the label representing a screen with the concatenation between its previous label and the label of the button.

[[[label=ex_speccalc_addatscreen|caption=code of Specalc>>addAtScreen:|language=Smalltalk|
Specalc>>addAtScreen: aLabel
	calcScreen label: (calcScreen label , aLabel) asNumber asString
]]]

In the following class side method ==defaultSpec==, the ==height:== is important to let enought place at the screen. Pay attention the argument of the ==add:== message are accessors refered by their symbols.

[[[label=ex_speccalc_defaultSpec|caption=code of Specalc class>>defaultSpec|language=Smalltalk|
Specalc>>defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newRow: [ :row | row add: #calcScreen ];
		newRow: [ :row | 
			row
				add: #button0;
				add: #button1;
				add: #button2 ]
			height: 50;
		yourself
]]]

The following ==title== method change the title of the window.

[[[caption=code of Specalc class>>title|language=Smalltalk|
Specalc>>title
	^ 'SpecCalculator'
]]]

Now, executing the code

[[[language=Smalltalk|
SpecCalc new openWithSpec
]]]

and click the buttons : 0, 0, 1, 0, 2 should give the figure *fig_SpecCalc_FirstWidget*.

+First SpecCalc widget.>file://figures/SpecCalc_FirstWidget.png|width=50|label=fig_SpecCalc_FirstWidget+


!!! Shortcut Instanciation

The superclass ==ComposableModel== provides shorcut methods for the most used basics widget.
 Its definition for ==newList== is the following one :

[[[caption=Implementation of ComposableModel>>newList|language=Smalltalk
ComposableModel>>newList
	^ self instantiate: ListModel
]]]



% ******************************************************************


!! Reusing Elements
@sec_reuse_spec

The following example show how build complex applications by reusing existing widget and managed their interactions. It's structured in four parts that will result in the browser shown in figure *@fig_protocol_browser*.

+A simple class browser composed of reusable elements.>file://figures/Protocol_Browser.png|width=80|label=fig_protocol_browser+

- First, the ""WidgetList"" : a widget dedicated to render ==ListModel==.
- Second, the ""ProtocolList"" : a widget composed of a ==ListModel== and a ==LabelModel==.
- Third, the ""ProtocolViewer"" : defined by combining a ==WidgetList== with two ==ProtocolList==, it will browse the methods in protocols named ''api'' and ''api-events''.
- Finally, the ""ProtocolBrowser"" : reuse a ==ProtocolViewer== and adding a ==TextModel==. 


!!! The WidgetList

The snippet *@ex_widgetlist_classcreation* shows the definition of this for the ==WidgetList== class.

[[[label=ex_widgetlist_classcreation|caption=WidgetList definition|language=Smalltalk 
ComposableModel subclass: #WidgetList
	instanceVariableNames: 'list'
	classVariableNames: ''
	package: 'Spec-Examples'
]]]

The first required step then is to instantiate and define the sub widgets.
This step is done in the method ==initializeWidgets== as shown in the code *@ex_WidgetList_initializeWidgets*. It creates the list and populates it with the required classes, in alphabetical order.
More details on the use of the ==initializeWidgets== method are given in Subsection *@subsec_initializeWidgets*.

[[[label=ex_WidgetList_initializeWidgets|caption=Implementation of WidgetList>>initializeWidgets|language=Smalltalk 
WidgetList>>initializeWidgets

	list := self newList.
	list items: (AbstractWidgetModel allSubclasses 
		sorted: [:a :b | a name < b name ]).
	self focusOrder add: list
]]]







The second required step is to define a layout, which is done on the class side.
Since there is here only one sub widget, the layout is quite simple, as shown in the code *@ex_WidgetList_layout*.
It simply returns a layout that contains only the list.
More details on the use of this method are given in Subsection *@subsec_layout*.

[[[label=ex_WidgetList_layout|caption=WidgetList layout|language=Smalltalk 
WidgetList class>>defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		add: #list;
		yourself
]]]

Pay attention the argument, ==#list==, of the ==add:== message, refers to a method that we did not define yet and that should return the associated UI element (here a list). 


The three last methods to define on WidgetList are a getter, a method to display the UI title and a method to register to list selection changes.
The code *@ex_WidgetList_others* shows the implementation of these three methods and their protocols.

[[[label=ex_WidgetList_others|caption=WidgetList other methods|language=Smalltalk 
WidgetList>>list
	^ list

WidgetList>>title
	^ 'Widgets'

WidgetList>>whenSelectedItemChanged: aBlock
	list whenSelectedItemChanged: aBlock
]]]

Note that this ==whenSelectedItemChanged: aBlock== will probably be deprecated in the future, since clients
can simply send the message to the list directly.

The first UI is now done.
The result can be seen by executing the following snippet of code: ==WidgetList new openWithSpec== as shown in figure *@fig_widget_list*

+The WidgetList Element.>file://figures/List.png|width=50|label=fig_widget_list+




!!! The ProtocolList

The next user interface that we will build is the protocol list.
This UI combines two widgets: a list and a label.
The class definition is similar to the code above, as can be seen in *@ex_protocolList_definition*.

[[[label=ex_protocolList_definition|caption=ProtocolList definition|language=Smalltalk 
ComposableModel subclass: #ProtocolList
	instanceVariableNames: 'label protocols'
	classVariableNames: ''
	package: 'Spec-Examples'
]]]

The ==initializeWidgets== method for this UI is quite similar to the method in WidgetList, as the code in *@ex_protocolList_init* shows.

[[[label=ex_protocolList_init|caption=ProtocolList implementation of initializeWidgets|language=Smalltalk 
ProtocolList>>initializeWidgets

	protocols := self newList.
	label := self newLabel.	
	label label: 'Protocol'.
	self focusOrder add: protocols
]]]


The layout method is quite different though.
Now the sub widgets need to be placed more specifically than in the previous example.
The code *@ex_protocolList_layout* shows how to build a column with the label on top and the list taking all the space that is left.

[[[label=ex_protocolList_layout|caption=ProtocolList layout|language=Smalltalk 
ProtocolList class>>defaultSpec
	<spec: #default>

	^ SpecLayout composed
		newColumn: [ :column |
			column
				add: #label
				height: self toolbarHeight;
				add: #protocols ];
		yourself
]]]

Note again that the arguments of the message ==add:== refer to methods that we will implement now. The remaining methods are getters, sub widget delegation methods, a method to display the title, and a method to register to list selection changes.
The code *@ex_protocolList_others* shows the implementations of these methods.

[[[label=ex_protocolList_others|caption=ProtocolList other methods|language=Smalltalk 
ProtocolList>>label
	^ label

ProtocolList>>protocols
	^ protocols

ProtocolList>>items: aCollection
	protocols items: aCollection
	
ProtocolList>>label: aText
	label text: aText
	
ProtocolList>>resetSelection
	protocols resetSelection
	
ProtocolList>>title
	^ 'Protocol widget'
	
ProtocolList>>whenSelectedItemChanged: aBlock
	protocols whenSelectedItemChanged: aBlock
]]]

Note again that the message ==whenSelectedItemChanged:== may be deprecated in the future.
We will see that the users may direcly register block using the accessors.

The ""ProtocolList"" UI can be seen by evaluating ==ProtocolList new openWithSpec==. As shown in Figure *@fig_protocollist*
the widgets is empty. This is normal since we did not initialize it. 

+The ProtocolList Element.>file://figures/EmptyProtocolList.png|width=50|label=fig_protocollist+


!!! The ProtocolViewer

The third user interface is a composition of the two previous user interfaces.
It is composed of a ""WidgetList"" and two ""ProtocolList"".
When a model class is selected, the methods in the protocol ''protocol'' and in the protocol ''protocol-events'' are listed.

The class has now three instance variables: ==models== to store the ""WidgetList"", ==protocols== to store the ""ProtocolList"" for the protocol ''protocol'', and ==events== to store the ""ProtocolList"" for protocol ''protocol-events''.
The code in *@ex_viewer_definition* shows the definition of the class ""ProtocolViewer"".

[[[label=ex_viewer_definition|caption=ProtocolViewer definition|language=Smalltalk 
ComposableModel subclass: #ProtocolViewer
	instanceVariableNames: 'models protocols events'
	classVariableNames: ''
	package: 'Spec-Examples'
]]]

The ==initializeWidgets== method now uses a different way to initialize the sub-widgets of the UI. 
This is because it does not use basic widgets but instead reuses the user interfaces we defined previously.
The remainder of the method is quite similar to the previous implementation, as shown in the code in *@ex_viewer_initializeWidgets*.

[[[label=ex_viewer_initializeWidgets|caption=Implementation of ProtocolViewer>>initializeWidgets|language=Smalltalk 
ProtocolViewer>>initializeWidgets

	models := self instantiate: WidgetList.
	protocols := self instantiate: ProtocolList.
	events := self instantiate: ProtocolList.
	
	protocols
		label: 'api';
		displayBlock: [ :m | m selector ].
	events
		label: 'api-events';
		displayBlock: [ :m | m selector ].
		
	self focusOrder 
		add: models;
		add: protocols;
		add: events
]]]

The layout puts the sub widgets in one column, with all sub widgets taking the same amount of space.
The code in *@ex_viewer_layout* shows the implementation of this layout.

[[[label=ex_viewer_layout|caption=ProtocolViewer column layout|language=Smalltalk 
ProtocolViewer class>>defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :column |
			column 
				add: #models; 
				add: #protocols; 
				add: #events ];
		yourself
]]]

To describe the interactions between the sub widgets, the method ==initializePresenter== needs to be defined.
Here, it specifies that when a class is selected, the selections in the protocol list are reset and both protocol lists are populated.
Additionally, when a method is selected in one protocol list, the selection in the other list is reset.
The implementation of this method is exposed in code *@ex_viewer_presenter*.
More details on the ==initializePresenter== method are given in *@subsec_initializePresenter*.

[[[label=ex_viewer_presenter|caption=ProtocolViewer sub widget interactions|language=Smalltalk
ProtocolViewer>>initializePresenter

	models whenSelectedItemChanged: [ :class |
		protocols resetSelection.
		events resetSelection.
		class
			ifNil: [ 
				protocols items: #().
				events items: #() ]
			ifNotNil: [ 
				protocols items: (self methodsIn: class for: 'api').
				events items: (self methodsIn: class for: 'api-events') ] ].
	
	protocols whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetEventSelection ] ].
	events whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetProtocolSelection ] ].
]]]

The remaining methods are getters, methods to delegate to sub widgets, one method to compute the methods in a specific class for a specific protocol, and methods to register to sub widget events.
Those methods are given in the code in *@ex_viewer_others*.

[[[label=ex_viewer_others|caption=ProtocolViewer other methods|language=Smalltalk 
	ProtocolViewer>>events
		^ events

	ProtocolViewer>>models
		^ models

	ProtocolViewer>>protocols
		^ protocols

	"private"
	ProtocolViewer>>methodsIn: class for: protocol
		^ (class methodsInProtocol: protocol) sorted: [ :a :b | a selector < b selector ]

	ProtocolViewer>>resetEventSelection
		events resetSelection

	ProtocolViewer>>resetProtocolSelection
		protocols resetSelection

	ProtocolViewer>>title
		^ 'Protocol viewer'

	ProtocolViewer>>whenClassChanged: aBlock
		models whenSelectedItemChanged: aBlock

	ProtocolViewer>>whenEventChangedDo: aBlock
		events whenSelectedItemChanged: aBlock

	ProtocolViewer>>whenProtocolChangedDo: aBlock
		protocols whenSelectedItemChanged: aBlock
]]]

As previously, the result can be seen by executing the following snippet of code: ==ProtocolViewer new openWithSpec==.

+The ProtocolViewer>file://figures/Protocol_Viewer.png|width=50|label=fig_protocol_Viewer+

!!! Protocol Browser
@subsec_protocol_browser

The last user interface reuses a ""ProtocolViewer"" with a different layout and adds a text zone to edit the source code of the selected method.
The class definition can be seen in code in *@ex_browser_definition*.

[[[label=ex_browser_definition|caption=ProtocolBrowser definition|language=Smalltalk 
ComposableModel subclass: #ProtocolBrowser
	instanceVariableNames: 'viewer text'
	classVariableNames: ''
	package: 'Spec-Examples'
]]]

The ==initializeWidgets== implementation is shown in the code in *@ex_browser_initializeWidgets*.

[[[label=ex_browser_initializeWidgets|caption=ProtocolBrowser>>initializeWidgets|language=Smalltalk 
initializeWidgets

	text := self newText.
	viewer := self instantiate: ProtocolViewer.
	text aboutToStyle: true.
	self focusOrder 
		add: viewer;
		add: text
]]]

The layout is more complex than the previous layouts.
Now the user interface mainly lays out widgets that are contained in its ==viewer== sub widget (the list of models and the two protocol browsers).
The layout is based on a column whose first row is divided in columns.
The implementation of this method is shown in code in *@ex_browser_layout*.

[[[label=ex_browser_layout|caption=ProtocolBrowser layout|language=Smalltalk 
defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :col | 
			col 
				newRow: [ :r | 
					r 
						add: #(viewer models);
					 	newColumn: [ :c | 
							c 
								add: #(viewer protocols);
								add: #(viewer events) ] ];
				add: #text
		];
		yourself
]]]

The ==initalizePresenter== method is used to make the text zone react to a selection in the lists.
When a method is seleted, the text zone updates its contents to show the source code  of the selected method.
The implementation of this method is detailled in the code in *@ex_browser_presenter*.

[[[label=ex_browser_presenter|caption=ProtocolBrowser interactions|language=Smalltalk 
ProtocolBrowser>>initializePresenter

	viewer whenClassChanged: [ :class | text behavior: class ].
	viewer whenProtocolChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ].
	viewer whenEventChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ]
]]]

The other methods are two getters, a method to set the default size, and a method to set the UI title.
Their implemenations are detailled in code *@ex_browser_others*.

[[[label=ex_browser_others|caption=ProtocolBrowser remaining methods|language=Smalltalk
	ProtocolBrowser>>text
		^ text

	ProtocolBrowser>>viewer
		^ viewer

	ProtocolBrowser>>initialExtent
		^ 750@600
	
	ProtocolBrowser>>title
		^ 'Protocols browser'
]]]

This finishes the protocol browser.
The final user interface can be opened with the following snippet: ==ProtocolBrowser new openWithSpec==.
The result can be seen in figure *@fig_second_protocol_browser*.
%spirita: an ancor named fig_protocol_browser already exists (its the same figure, give the same name create problems in reference).

+The ProtocolBrowser>file://figures/Protocol_Browser.png|width=50|label=fig_second_protocol_browser+


!!! Adding Menu and KeyBinding

may be this should be adding in the flow.



