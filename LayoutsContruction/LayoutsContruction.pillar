{ "title" : "Layout Construction"}
@cha_layout_construction

@@todo JF editorial pass

@@todo JF complete intro

In  this chapter, we use an example class that has two buttons, a list and a text field, the code of which is below:

[[[
ComposableModel subclass: #LayoutExample
	instanceVariableNames: 'list button button2 text'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'

LayoutExample >> initializeWidgets
	button := self newButton.
	button2 := self newButton.
	list := self newList.
	text := self newText.
	
	button label: 'i am a button'.
	button label: 'me too!'.
]]]

!! Only One Widget

@@todo JF This text need thorough reworking.
@@todo JF missing some explanation of always trying to take up all available space

The simpliest example of such a method is laying out just one widget. Below we present such a layout.

It returns a layout in which just one widget is added: the widget contained in ==theList== instance variable.

[[[^ SpecLayout composed
		add: #theList;
		yourself
]]]

The symbol ==theList== refers to an instance side method returning a widget.
This is because instance variables are private, so the layout class needs to use an accessor to obtain it when building the UI.

@@note By default, a widget will take all the space available in its container.

All the methods for adding sub widgets can be found in the ''commands'' and ''commands-advanced'' protocols of ""SpecLayout"".


Also, these methods are ''not'' restricted to laying out sub widgets.

It can also refer to sub widgets contained in sub widgets, i.e. when
reusing an existing UI, specify a new layout for the sub widgets that
comprise this UI.

To do this, instead of giving a symbol, an array with 2 (or more) symbols must
be given.

The first symbol identifies the UI being reused and the second the sub
widget within this UI whose new layout position is being specified.

We have seen an example of this reuse in *@sec_protocolbrowser*.


!! Row and column layouts

A straightforward and often used kind of layout is to have widgets aligned in rows or columns.
Spec provides for an easy way to specify such layouts through the use of the ==newRow:== and ==newColumn:== messages on the ==SpecLayout== class.
They create, respectively, a row or a column in which all widgets are evenly distributed.

For example, the code below lays out the list and the button in a row:

[[[
LayoutExample >> oneRow
	^ SpecLayout composed
		newRow: [ :row |
			row
				add: #theList;
				add: #theButton
		];
		yourself
]]]

+Screen shot of a row of widgets.>file://figures/RowOfWidgets.png|width=50|label=fig_RowOfWidgets+

This code is a layout method that builds a row of widgets using the ==newRow:== message.
The argument of the message is a one-argument block, and the block argument will contain an instance of a ==SpecRowLayout==.
The widgets are then added to this layout object, which aligns them all in a row.

The code below opens the example with this layout specification, resulting in the UI shown in Figure *@fig_RowOfWidgets*. (The use of the ==title:== message will be explained in Chapter *@cha_managing_windows*.)

[[[
| le |
 le := LayoutExample new.
 le title: 'RowOfWidgets'.
 le openWithSpec: #oneRow
]]]


Having the widgets rendered as a column is similar, the only real difference being that instead of the ==newRow:== message, a ==newColumn== message is used.
This message also takes a one-argument block, and the block argument will contain an instance of a ==SpecColumnLayout==.

[[[
LayoutExample >> oneColumn
	^ SpecLayout composed
		newColumn: [ :col |
			col
				add: #list;
				add: #button
		];
		yourself
]]]

The code below opens this example, resulting in Figure *@fig_ColumnOfWidgets*. 

+Screen shot of a column of widgets>file://figures/ColumnOfWidgets.png|width=50|label=fig_ColumnOfWidgets+

[[[
| le |
 le := LayoutExample new.
 le title: 'ColumnOfWidgets'.
 le openWithSpec: #oneColumn.
]]]

Note that for brevity, in the remainder of this chapter we will not include any more UI opening code as it is straightforward.


Spec also allows for using the ==SpecRowLayout== and ==SpecColumnLayout== directly instead of using a ==SpecLayout==.
This makes the above code for the ==oneRow== and ==oneColumn== layout methods more concise:

[[[
LayoutExample >> oneRowConcise
	^ SpecRowLayout composed
			add: #list;
			add: #button;
			yourself.

LayoutExample >> oneColumnConcise
	^ SpecColumnLayout composed
			add: #list;
			add: #button;
			yourself
]]]


!! Combining rows and columns


Rows and columns can be combined to build more complex layouts, by sending both the ==newRow:== and ==newColumn:== messages in different combinations. 
We show some examples here to illustrate the possibilities.

The first example shows how we can have two rows of widgets: we create a column and twice call ==newRow:==. The result is shown in Figure *@fig_TwoRows*.


+Screen shot of two rows>file://figures/TwoRows.png|width=50|label=fig_TwoRows+


[[[
LayoutExample >> twoRows
	^ SpecColumnLayout composed
		newRow: [ :row | row add:#text];
		newRow: [ :row |
			row
				add: #button;
				add: #button2
		];
		yourself
]]]

@@note To have multiple rows, these need to be added to a ==SpecColumnLayout==, and to have multiple columns, these need to be added to a ==SpecRowLayout==. Sending ==addRow:== or ==addColumn:== to a ==SpecComposedLayout== multiple times will only produce the last row, resp. column.

Rows and columns can of course also be multiply-nested, for example here we add the two buttons in a row that is nested in a column that is nested in a ==SpecRowLayout==. The resulting UI is shown in Figure  *@fig_DoubleNesting*.


+Screen shot of multiply-nested rows and columns>file://figures/DoubleNesting.png|width=50|label=fig_DoubleNesting+

[[[
LayoutExample >> nesting1
	^ SpecRowLayout composed
		newColumn: [ :col | col add: #list];
		newColumn: [ :col |
			col
				add: #text;
				newRow: [ :row |
					row
						add: #button;
						add: #button2]
		];
		yourself
]]]

In addition to nesting columns in rows (and vice-versa), rows can also be nested in rows (and columns in columns), which allows the used space per widget to be uniformly halved, as shown in Figure *@fig_DoubleNestingUniform*

+Screen shot of multiply-nested rows>file://figures/DoubleNestingUniform.png|width=50|label=fig_DoubleNestingUniform+

[[[
LayoutExample >> nesting2
	^ SpecColumnLayout composed
		newRow: [ :row | row add: #list];
		newRow: [ :row |
			row
				add: #text;
				newRow: [ :inRow |
					inRow
						add: #button;
						add: #button2]
		];
		yourself
]]]


!! Setting row and column size

By default, rows and columns take up all available space, and the space in a row (and in a column) is evenly distributed across all elements of that row (or column).
In this section we show three different ways in which the size of rows and columns can be changed.
The first is by letting the user resize them and the two last are two different ways in which their size can be specified.


!!! Adding UI splitters so the user can resize

A simple resizing option is to allow the user to resize widgets horizontally (for rows) and vertically (for columns).
This is done by adding an ==addSplitter== message between the ==add:== messages for the widgets of that row or column.
For example, the code below makes the horizontal line between the list and the button draggable up or down. Visually the result is the same as in Figure *@fig_ColumnOfWidgets*.

[[[
LayoutExample >> oneColumnWithSplitter
	^ SpecColumnLayout composed
			add: #list;
			addSplitter;
			add: #button;
			yourself
]]]



!!! Size in pixels

Programmatically it is possible to explicitly specify the absolute size of a row or column in pixels by using the ==newRow:height:== and ==newColumn:width:== methods. 
This is useful, for example, if a row of buttons is to be placed above or below a text field where it can avoid an ugly layout with huge buttons as seen previously in Figure *@fig_TwoRows*.

We show two simple examples of the use of absolute size below, the first leading to the UI of Figure *@fig_Row30pixels* and the second to the UI of Figure *@fig_Column50pixels*.

[[[
LayoutExample >> rowOf30
	^ SpecLayout composed
		newRow: [ :row |
			row
				add: #list;
				add: #button
		] height: 30;
		yourself
]]]

[[[
LayoutExample >> columnOf50
	^ SpecLayout composed
		newColumn: [ :column | 
			column
				add: #list;
				add: #button
			] width: 50;
		yourself
]]]

+Screen shot of a row of 30 pixels high.>file://figures/Row30pixels.png|width=50|label=fig_Row30pixels+

+Screen shot of a column of 50 pixels wide.>file://figures/Column50pixels.png|width=50|label=fig_Column50pixels+

@@note It is considered a bad practice to hardcode the size of widgets in pixels, as changes in e.g., font size can invalidate this number. To alleviate this, ==ComposableModel class== provides accessors for practical sizes in its ==defaults== protocol. For example ==toolbarHeight== depends on the font size and is useful for sizing button rows.

!!! Proportional layout
@sec_rows_columns_proportional

A last option is to specify the percentage of the container, e.g. the window, that a row or column should occupy.
This is performed using the messages ==newRow:top:bottom:== and ==newColumn:left:right:==.
In contrast with specifying size in pixels, the use of these messages will cause the row or column size to change accordingly when the container is resized.

Both the above messages take two numbers as extra arguments.
These should be between 0 and 1: they are a percentage that states how far ""towards the other edge"" the element should begin, resp. end.
For example, a column that starts at the left end of the window and takes 30 percent of the width is a ==newColumn: [:c| ...] left: 0 right: 0.7== because 30 percent of the width is 70 percent away from the right edge.

@@note Both these numbers indicate a percentage that is towards 'the other end' of the containter, ""not"" a percentage from top to bottom or from left to right.

A more complex example is the code below, an arguably artificial variant on Figure *@fig_DoubleNestingUniform* that makes the buttons proportionally smaller.
(The example is artificial because, e.g., for the row height of the buttons it would make more sense to use sizes in pixels.)
It states that the top row takes the first 80 percent of the space (since ==top: 0 bottom: 0.2==) and the second row the last 20 percent (since ==top: 0.8 bottom: 0==).
Furthermore, in the bottom row, the text field takes up the first 55 percent of the space (==left: 0 right: 0.45==) and the two buttons the last 45 percent (==left: 0.55 right:0==).
The result of this code can be seen in Figure *@fig_ProportionalRowsCols*.

[[[
nestingTB
	^ SpecColumnLayout composed
		newRow: [ :row | row add: #list] top: 0 bottom: 0.2 ;
		newRow: [ :row |
			row
				newColumn: [:c | c add: #text] left: 0 right: 0.45;
				newColumn: [ :c |
					c newRow: [ :inRow |
						inRow
							add: #button;
							add: #button2]] left: 0.55 right: 0
		] top: 0.8 bottom: 0 ;
		yourself
]]]

+Screen shot of a use of proportional rows and columns.>file://figures/ProportionalRowsCols.png|width=50|label=fig_ProportionalRowsCols+

!! Layouts without rows or columns


!!! Absolute widget positions

[[[
LayoutExample >> oneButtonAbsolute
	^ SpecLayout composed
		add: #button top: 10 bottom: 200 left: 10 right: 10;
		yourself
]]]

@@note The underlying logic of the arguments is the same as in ==newRow:top:bottom:== and ==newColumn:left:right== of Section *@sec_rows_columns_proportional*: distances are towards the 'other end' of the container.

+Screen shot of an absolutely placed Button>file://figures/AbsoluteButton.png|width=50|label=fig_AbsoluteButton+

@@note Obviously, the use of absolute widget positions breaks completely if a window is resized. It is therefore best to use this only in combination with windows that cannot be resized.

!!! Relative widget positions

[[[
LayoutExample >> oneButtonSmaller
	^ SpecLayout composed
		add: #button origin: (0.25 @ 0.25) corner: (0.75 @ 0.75);
		yourself
]]]

+Screen shot of an always centered Button>file://figures/CentreredButton.png|width=50|label=fig_CentreredButton+


!!! Relatives with offsets



[[[
LayoutExample >> twoButtonsRelativeOffset
	^ SpecLayout composed
		add: #button origin: (0 @ 0) corner: (1 @ 0.5) offsetOrigin: (10 @ 10) offsetCorner: (-10 @ -5) ;
		add: #button2 origin: (0 @ 0.5 ) corner: (1 @ 1) offsetOrigin: (10 @ 5) offsetCorner: (-10 @ -10);
		yourself
]]]

!! ORPHAN

To do so, the proportional position of the four sides of a widget can be specified, as shown in the example *@ex_layout_proportional*. For each edge, the proportion indicates at what percentage of the overall container the edge should be placed.

Zero percent is the container edge, 100 percent is the opposite container edge.
For example, for the top edge, the percentage is counted from the top down: 0 is the top edge, and 1 is the bottom edge.

[[[
^ SpecLayout composed
	add: #theButton top: 0.25 bottom: 0.25 left: 0.25 right: 0.25;
	yourself
]]]



!! Absolute offsets

@@todo Missing an example
Also, the argument can be an integer if the offset has to be a fixed number of pixels.
The number of pixels should be positive, as it indicates a distance from the corresponding edge, going to the opposite edge.

!! Proportional with offsets
@sec_layout_expert

!!! origin: corner:

The previous examples should cover most of the cases of layout of widgets.
For the remaining cases there is a last way to specify a widget by specifying its position, in case everything else fails.

The method ==add: origin: corner: == of ==SpecLayout== specifies the layout of a widget, percentage-wise from the origin point to the corner point.

These two points represent respectively the top left corner and the bottom right corner of the widget. The arguments express a percentage of the container, so these __must__ be between ''0@0'' and ''1@1'' .


!!! Addition offsetOrigin: offsetCorner: 

In addition to origin and corner , two offsets can be also be specified, using the method ==add: origin: corner: offsetOrigin: offsetCorner: ==.

The offsets specify the number of pixels that the origin and the corner should be moved.

Contrary to the previous way to define layouts, while using ==add: origin: corner:  offsetOrigin: offsetCorner: == the offset can be negative.
The offset expresses the number of pixels from the corresponding corner, in the classical computer graphics coordinate system where the origin is in the top left corner.
Note that this approach is similar to the ProportionalLayout of ""Morphic"".


The example below shows how to add a widget looking like a toolbar.
Here we reuse theButton for simplicity, we specify that it take all the window width but only 30 pixels in height.

[[[
^ SpecLayout composed
				add: #theButton
					origin: 0 @ 0
					corner: 1 @ 0
					offsetOrigin: 0 @ 0
					offsetCorner: 0 @ 30;
				yourself
]]]

+Render of a Toolbar made with the Expert Mode>file://figures/ExpertModeToolbar.png|width=50|label=fig_ExpertModeToolbar+

