{ "title" : "Reusing and composing elements"}
@cha_reuse

@@todo JF editorial pass


@@todo JF add the emphasis on reuse and how it shapes design of spec and that your UIs should be compliant so they can be reused

@@todo JF the code for the 2 first examples can be treated quickly since we just saw stuff like this in the previous chapter.

In this chapter we will show the power of Spec at work to build complex applications by reusing existing widgets and managed their interactions.

+Render of the ProtocolBrowser>file://figures/Protocol_Browser.png|width=50|label=fig_protocol_browser+

It's structured in four parts that will result in the browser shown in Figure *@fig_protocol_browser*:
- First, the ""WidgetClassList"" : a widget dedicated to render ==ListModel== displaying AbstractWidgetModel subclasses.
- Second, the ""ProtocolList"" : a widget composed of a ==ListModel== and a ==LabelModel==.
- Third, the ""ProtocolViewer"" : defined by combining a ==WidgetClassList== with two ==ProtocolList==, it will browse the methods in protocols named ''api'' and ''api-events''.
- Finally, the ""ProtocolBrowser"" : reuse a ==ProtocolViewer== and adding a ==TextModel==.

This composition is shown by the diagram *@fig_protocolbrowser_hierarchy*.

+Diagram of hierarchy of parents of ProtocolBrowser>file://figures/ProtocolBrowserHierarchy.png|label=fig_protocolbrowser_hierarchy+



!! Using a basic widget 
@sec_WidgetClassList

[[[
ComposableModel subclass: #WidgetClassList
	instanceVariableNames: 'list'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

In the method ==initializeWidgets==, we create the list and populates it with the required classes, in alphabetical order.

[[[
WidgetClassList >> initializeWidgets
	list := self newList.
	list items: (AbstractWidgetModel allSubclasses
		 							 sorted: [:a :b | a name < b name ]).
	self focusOrder add: list
]]]

The layout contains only the list.
x
[[[
WidgetClassList class >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		add: #list;
		yourself
]]]

The three last methods to define on WidgetClassList are the getter of the list, a method to display the UI title and a method to register to list selection changes.

[[[
WidgetClassList >> title
	^'Widgets'
]]]

[[[
WidgetClassList >> whenSelectedItemChanged: aBlock
	list whenSelectedItemChanged: aBlock
]]]

@@note ==whenSelectedItemChanged: aBlock== will probably be deprecated in the future, since clients can simply send the message to the list directly.

The result can be seen by executing the following snippet of code: ==WidgetClassList new openWithSpec== as shown in figure *@fig_WidgetClassList*

+Render of the WidgetClassList>file://figures/WidgetClassList.png|width=50|label=fig_WidgetClassList+



!! Combining two basic widgets
@sec_protocollist

This UI combines two widgets: a list and a label.

[[[
ComposableModel subclass: #ProtocolList
	instanceVariableNames: 'label protocols'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

The ==initializeWidgets== method for this UI is quite similar to the method in WidgetClassList:

[[[
ProtocolList >> initializeWidgets
	protocols := self instantiate: ListModel.
	label :=  self instantiate: LabelModel.
	label label: 'Protocol'.
	self focusOrder add: protocols
]]]

The code below shows how to build a column with the label on top and the list taking all the space that is left.

@@todo JF SpecColumnLayout use

[[[
ProtocolList class >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newColumn: [ :column |
			column
				add: #label
				height: self toolbarHeight;
				add: #protocols ];
		yourself
]]]

The remaining methods are getters, sub widget delegation methods, a method to display the title, and a method to register to list selection changes.

The ""ProtocolList"" UI can be seen by evaluating ==ProtocolList new openWithSpec==. As shown in Figure *@fig_protocollist* the widgets is empty. This is normal since we did not initialize it. 

+Render of the ProtocolList>file://figures/ProtocolList.png|width=50|label=fig_protocollist+


!! Managing three widgets and their interactions
@sec_protocolviewer

The third user interface is a composition of the two previous user interfaces.
It is composed of a ==WidgetClassList== and two ==ProtocolList==, and manage the reaction when a model class is selected in the ==WidgetClassList==, to make the methods in the protocol ''api'' and in the protocol ''api-events'' listed in the two ==ProtocolList==.

The code in *@ex_viewer_definition* shows the definition of the class ==ProtocolViewer==.

[[[
ComposableModel subclass: #ProtocolViewer
	instanceVariableNames: 'models protocols events'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

The ==initializeWidgets== method now initializes the ==ProtocolList==, but not the ==WidgetClassList== as it already intiialize itself.

[[[
ProtocolViewer >> initializeWidgets

	models := self instantiate: WidgetClassList.
	protocols := self instantiate: ProtocolList.
	events := self instantiate: ProtocolList.
	
	protocols
		label: 'api';
		displayBlock: [ :m | m selector ].
	events
		label: 'api-events';
		displayBlock: [ :m | m selector ].
		
	self focusOrder 
		add: models;
		add: protocols;
		add: events
]]]

The layout puts the sub widgets in one column, with all sub widgets taking the same amount of space.

@@todo ColumnLayout composed

[[[
ProtocolViewer class >> defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :column |
			column 
				add: #models; 
				add: #protocols; 
				add: #events ];
		yourself
]]]

To describe the interactions between the sub widgets, the method ==initializePresenter== needs to be defined.
- Here, it specifies that when a class is selected, the selections in the protocol list are reset and both protocol lists are populated.
- Additionally, when a method is selected in one protocol list, the selection in the other list is reset.

[[[
ProtocolViewer >> initializePresenter

	models whenSelectedItemChanged: [ :class |
		protocols resetSelection.
		events resetSelection.
		class
			ifNil: [ 
				protocols items: #().
				events items: #() ]
			ifNotNil: [ 
				protocols items: (self methodsIn: class for: 'api').
				events items: (self methodsIn: class for: 'api-events') ] ].
	
	protocols whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetEventSelection ] ].
	events whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetProtocolSelection ] ].
]]]

The remaining methods are getters, methods to delegate to sub widgets, one method to compute the methods in a specific class for a specific protocol, and methods to register to sub widget events.
Those methods are given in the code in *@ex_viewer_others*.

[[[
ProtocolViewer >> events
	^ events

ProtocolViewer >> models
	^ models

ProtocolViewer >> protocols
	^ protocols

ProtocolViewer >> methodsIn: class for: protocol
	^ (class methodsInProtocol: protocol) sorted: [ :a :b | a selector < b selector ]

ProtocolViewer >> resetEventSelection
	events resetSelection

ProtocolViewer >> resetProtocolSelection
	protocols resetSelection

ProtocolViewer >> title
	^ 'Protocol viewer'

ProtocolViewer >> whenClassChanged: aBlock
	models whenSelectedItemChanged: aBlock

ProtocolViewer >> whenEventChangedDo: aBlock
	events whenSelectedItemChanged: aBlock

ProtocolViewer >> whenProtocolChangedDo: aBlock
	protocols whenSelectedItemChanged: aBlock
]]]

As previously, the result can be seen by executing the following snippet of code: ==ProtocolViewer new openWithSpec==.

+Render of the ProtocolViewer>file://figures/Protocol_Viewer.png|width=50|label=fig_protocol_Viewer+



!! Changing the layout of a reused widget
@sec_protocolbrowser

@@todo JF emphasize that this is about changing the layout of a widget that is being reused.

The last user interface reuses a ==ProtocolViewer== with a different layout and adds a text zone to edit the source code of the selected method.

[[[
ProtocolBrowser >> initializeWidgets
	text := self instantiate: TextModel.
	viewer := self instantiate: ProtocolViewer.
	text
		aboutToStyle: true;
		isCodeCompletionAllowed: true.
	self focusOrder 
		add: viewer;
		add: text
]]]

The following messages are dedicated at code:
- ==aboutToStyle:== stylised the text according to the syntaxe.
- ==isCodeCompletionAllowed:==, argument '''true''' enables the completion of the tipping code.

Now the user interface mainly lays out widgets that are contained in its ==viewer== sub widget (the list of models and the two protocol browsers).

[[[
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :col | 
			col 
				newRow: [ :r | 
					r 
						add: #(viewer models);
					 	newColumn: [ :c | 
							c 
								add: #(viewer protocols);
								add: #(viewer events) ] ];
				add: #text
		];
		yourself
]]]

The ==initalizePresenter== method is used to make the text zone react to a selection in the lists.
When a method is seleted, the text zone updates its contents to show the source code  of the selected method.

[[[
	viewer whenClassChanged: [ :class | text behavior: class ].
	viewer whenProtocolChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ].
	viewer whenEventChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ]
]]]

The other methods are getters, a method to set the default size of the window, and a method to set the UI title.

The final user interface can be opened with the following snippet: ==ProtocolBrowser new openWithSpec==. The result can be seen in figure *@fig_protocol_browser*.


!! Conclusion

@@todo JF Reinforce the reuse story and what you should do to comply
