{ "title" : "Reusing Elements"}
@cha_reuse

In this chapter we will show the power of Spec at work to build complex applications by reusing existing widgets and managed their interactions.

It's structured in four parts that will result in the browser shown in figure *@fig_protocol_browser*:
- First, the ""WidgetClassList"" : a widget dedicated to render ==ListModel== displaying AbstractWidgetModel subclasses.
- Second, the ""ProtocolList"" : a widget composed of a ==ListModel== and a ==LabelModel==.
- Third, the ""ProtocolViewer"" : defined by combining a ==WidgetClassList== with two ==ProtocolList==, it will browse the methods in protocols named ''api'' and ''api-events''.
- Finally, the ""ProtocolBrowser"" : reuse a ==ProtocolViewer== and adding a ==TextModel==.

This composition is shown by the diagram *@fig_protocolbrowser_hierarchy*.

+Diagram of hierarchy of parents of ProtocolBrowser>file://figures/ProtocolBrowserHierarchy.png|label=fig_protocolbrowser_hierarchy+



!! Using a Basic Widget 
@sec_WidgetClassList

[[[label=ex_WidgetClassList_classcreation|caption=Creation of the class WidgetClassList|language=Smalltalk 
ComposableModel subclass: #WidgetClassList
	instanceVariableNames: 'list'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

In the method ==initializeWidgets==, we create the list and populates it with the required classes, in alphabetical order.

[[[label=ex_WidgetClassList_initializeWidgets|caption=Code of WidgetClassList>>initializeWidgets|language=Smalltalk 
WidgetClassList >> initializeWidgets
	list := self newList.
	list items: (AbstractWidgetModel allSubclasses 
		sorted: [:a :b | a name < b name ]).
	self focusOrder add: list
]]]

The layout contains only the list.

[[[label=ex_WidgetClassList_layout|caption=Code of WidgetClassList class >> defaultSpec|language=Smalltalk 
WidgetClassList class >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		add: #list;
		yourself
]]]

The three last methods to define on WidgetClassList are the getter of the list, a method to display the UI title and a method to register to list selection changes.

[[[label=ex_WidgetClassList_register|caption=WidgetClassList other methods|language=Smalltalk 
WidgetClassList>>whenSelectedItemChanged: aBlock
	list whenSelectedItemChanged: aBlock
]]]

Note that this ==whenSelectedItemChanged: aBlock== will probably be deprecated in the future, since clients can simply send the message to the list directly.

The result can be seen by executing the following snippet of code: ==WidgetClassList new openWithSpec== as shown in figure *@fig_WidgetClassList*

+Render of the WidgetClassList>file://figures/WidgetClassList.png|width=50|label=fig_WidgetClassList+



!! Render of two Basic Widgets
@sec_protocollist

This UI combines two widgets: a list and a label.

[[[label=ex_protocolList_definition|caption=Creation of the class ProtocolList|language=Smalltalk 
ComposableModel subclass: #ProtocolList
	instanceVariableNames: 'label protocols'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

The ==initializeWidgets== method for this UI is quite similar to the method in WidgetClassList, as the code in *@ex_protocolList_init* shows.

[[[label=ex_protocolList_init|caption=Code of ProtocolList >> initializeWidgets|language=Smalltalk 
ProtocolList >> initializeWidgets
	protocols := self instantiate: ListModel.
	label :=  self instantiate: LabelModel.
	label label: 'Protocol'.
	self focusOrder add: protocols
]]]

The code *@ex_protocolList_layout* shows how to build a column with the label on top and the list taking all the space that is left.

[[[label=ex_protocolList_layout|caption=Code of ProtocolList class >> defaultSpec|language=Smalltalk 
ProtocolList class >> defaultSpec
	<spec: #default>
	^ SpecLayout composed
		newColumn: [ :column |
			column
				add: #label
				height: self toolbarHeight;
				add: #protocols ];
		yourself
]]]

The remaining methods are getters, sub widget delegation methods, a method to display the title, and a method to register to list selection changes.

The ""ProtocolList"" UI can be seen by evaluating ==ProtocolList new openWithSpec==. As shown in Figure *@fig_protocollist* the widgets is empty. This is normal since we did not initialize it. 

+Render of the ProtocolList>file://figures/ProtocolList.png|width=50|label=fig_protocollist+


!! Managing three Widgets and their interactions
@sec_protocolviewer

The third user interface is a composition of the two previous user interfaces.
It is composed of a ==WidgetClassList== and two ==ProtocolList==, and manage the reaction when a model class is selected in the ==WidgetClassList==, to make the methods in the protocol ''api'' and in the protocol ''api-events'' listed in the two ==ProtocolList==.

The code in *@ex_viewer_definition* shows the definition of the class ==ProtocolViewer==.

[[[label=ex_viewer_definition|caption=Creation of the class ProtocolViewer|language=Smalltalk 
ComposableModel subclass: #ProtocolViewer
	instanceVariableNames: 'models protocols events'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec-Reuse'
]]]

The ==initializeWidgets== method now initializes the ==ProtocolList==, but not the ==WidgetClassList== as it already intiialize itself.

[[[label=ex_viewer_initializeWidgets|caption=Code of ProtocolViewer >> initializeWidgets|language=Smalltalk 
ProtocolViewer >> initializeWidgets

	models := self instantiate: WidgetClassList.
	protocols := self instantiate: ProtocolList.
	events := self instantiate: ProtocolList.
	
	protocols
		label: 'api';
		displayBlock: [ :m | m selector ].
	events
		label: 'api-events';
		displayBlock: [ :m | m selector ].
		
	self focusOrder 
		add: models;
		add: protocols;
		add: events
]]]

The layout puts the sub widgets in one column, with all sub widgets taking the same amount of space.

[[[label=ex_viewer_layout|caption=Code of ProtocolViewer class >> defaultSpe|language=Smalltalk 
ProtocolViewer class >> defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :column |
			column 
				add: #models; 
				add: #protocols; 
				add: #events ];
		yourself
]]]

To describe the interactions between the sub widgets, the method ==initializePresenter== needs to be defined.
- Here, it specifies that when a class is selected, the selections in the protocol list are reset and both protocol lists are populated.
- Additionally, when a method is selected in one protocol list, the selection in the other list is reset.

[[[label=ex_viewer_presenter|caption=Code of ProtocolViewer >> initializePresenter|language=Smalltalk
ProtocolViewer >> initializePresenter

	models whenSelectedItemChanged: [ :class |
		protocols resetSelection.
		events resetSelection.
		class
			ifNil: [ 
				protocols items: #().
				events items: #() ]
			ifNotNil: [ 
				protocols items: (self methodsIn: class for: 'api').
				events items: (self methodsIn: class for: 'api-events') ] ].
	
	protocols whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetEventSelection ] ].
	events whenSelectedItemChanged: [ :method | method ifNotNil: [ self resetProtocolSelection ] ].
]]]

The remaining methods are getters, methods to delegate to sub widgets, one method to compute the methods in a specific class for a specific protocol, and methods to register to sub widget events.
Those methods are given in the code in *@ex_viewer_others*.

[[[label=ex_viewer_others|caption=Code of ProtocolViewer other methods|language=Smalltalk 
	ProtocolViewer>>events
		^ events

	ProtocolViewer>>models
		^ models

	ProtocolViewer>>protocols
		^ protocols

	"private"
	ProtocolViewer>>methodsIn: class for: protocol
		^ (class methodsInProtocol: protocol) sorted: [ :a :b | a selector < b selector ]

	ProtocolViewer>>resetEventSelection
		events resetSelection

	ProtocolViewer>>resetProtocolSelection
		protocols resetSelection

	ProtocolViewer>>title
		^ 'Protocol viewer'

	ProtocolViewer>>whenClassChanged: aBlock
		models whenSelectedItemChanged: aBlock

	ProtocolViewer>>whenEventChangedDo: aBlock
		events whenSelectedItemChanged: aBlock

	ProtocolViewer>>whenProtocolChangedDo: aBlock
		protocols whenSelectedItemChanged: aBlock
]]]

As previously, the result can be seen by executing the following snippet of code: ==ProtocolViewer new openWithSpec==.

+Render of the ProtocolViewer>file://figures/Protocol_Viewer.png|width=50|label=fig_protocol_Viewer+



!! TextModel and basic Change of the Layout
@sec_protocolbrowser

The last user interface reuses a ==ProtocolViewer== with a different layout and adds a text zone to edit the source code of the selected method.

[[[label=ex_browser_initializeWidgets|caption=Code of ProtocolBrowser >> initializeWidgets|language=Smalltalk 
initializeWidgets
	text := self instantiate: TextModel.
	viewer := self instantiate: ProtocolViewer.
	text
		aboutToStyle: true;
		isCodeCompletionAllowed: true.
	self focusOrder 
		add: viewer;
		add: text
]]]

The following messages are dedicated at code:
- ==aboutToStyle:== stylised the text according to the syntaxe.
- ==isCodeCompletionAllowed:==, argument '''true''' enables the completion of the tipping code.

Now the user interface mainly lays out widgets that are contained in its ==viewer== sub widget (the list of models and the two protocol browsers).

[[[label=ex_browser_layout|caption=Code of ProtocolBrowser class >> defaultSpec|language=Smalltalk 
ProtocolBrowser class >> defaultSpec
	<spec: #default>
	
	^ SpecLayout composed
		newColumn: [ :col | 
			col 
				newRow: [ :r | 
					r 
						add: #(viewer models);
					 	newColumn: [ :c | 
							c 
								add: #(viewer protocols);
								add: #(viewer events) ] ];
				add: #text
		];
		yourself
]]]

The ==initalizePresenter== method is used to make the text zone react to a selection in the lists.
When a method is seleted, the text zone updates its contents to show the source code  of the selected method.

[[[label=ex_browser_presenter|caption=Code of ProtocolBrowser >> initializePresenter|language=Smalltalk 
ProtocolBrowser >> initializePresenter
	viewer whenClassChanged: [ :class | text behavior: class ].
	viewer whenProtocolChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ].
	viewer whenEventChangedDo: [ :item | 
		item 
			ifNil: [ text text: '' ]
			ifNotNil: [ text text: item sourceCode ] ]
]]]

The other methods are getters, a method to set the default size of the window, and a method to set the UI title.

The final user interface can be opened with the following snippet: ==ProtocolBrowser new openWithSpec==. The result can be seen in figure *@fig_protocol_browser*.

+Render of the ProtocolBrowser>file://figures/Protocol_Browser.png|width=50|label=fig_protocol_browser+

