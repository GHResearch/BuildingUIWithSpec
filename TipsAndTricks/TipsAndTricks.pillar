{
	"metadata" : {
		"title" : "Tips and Tricks"
	}
}
@cha_tips_and_tricks

This chapter collects many small examples of features that may be of
use when building user interfaces with Spec. For the sake of brevity,
some examples use dynamic Spec (see chapter *@cha_dynamic_spec*), but these
of course also work without using the dynamic features of Spec.
Most of the examples are short snippets of code that should be auto-explicative.

!! Include a Morph in a Spec UI

Any morph can be included as a widget in a Spec UI. To do this, send
the Morph instance the ==asSpecAdapter== message, it will return a
Spec widget that can be used in your UI.

As an example, below we show the code that turns the ==CalendarMorph== into a plain Spec UI, opened with ==SpecCalendar new openWithSpec==:

[[[
ComposableModel subclass: #SpecCalendar
	instanceVariableNames: 'morph'
	classVariableNames: ''
	package: 'Spec-BuildUIWithSpec'
]]]

[[[
SpecCalendar >> initializeWidgets
	morph := (CalendarMorph openOn: Date today) asSpecAdapter
]]]

[[[
SpecCalendar class >> defaultSpec
	^SpecLayout composed add: #morph; yourself
]]]

[[[
SpecCalendar >> extent
	^220@200
]]]

[[[
SpecCalendar >> title
	^'SpecCalendar'.
]]]


!! Include a Glamour UI in a Spec UI


User interfaces written in Glamour can also be embedded in a Spec UI thanks to a bridge class ==GlamourPresentationModel==. This is a ==ComposableModel== subclass that wraps Glamour user interfaces such as the Playground or the Inspector.

For this functionality to work in Pharo 5 you should first load the integration package:

[[[
Gofer it
		smalltalkhubUser: 'jfabry' project: 'Playground';
		package: 'Spec-Glamour';
		load
]]]

The ==GlamourPresentationModel== by default wraps the Playground, which means that we can open a Spec window on a Glamour Playground as follows: ==GlamourPresentationModel new openWithSpec==.

To use another Glamour UI, the ==GlamourPresentationModel== must be configured before it is opened, sending it the ==presentationClass:startOn:== message, with as arguments the class of the Glamour UI and the data to be shown in the UI. For example, below we open the inspector on 42 (in a Spec window).

[[[
| cm |
 cm := GlamourPresentationModel new.
 cm presentationClass: GTInspector startOn: 42.
 cm openWithSpec
]]]

The GT Playground is a bit unusual in the data that it opens on, this data must be a ==GTPlayPage== instance, for example as below.

[[[
| cm |
 cm := GlamourPresentationModel new.
 cm presentationClass: GTPlayground startOn: (GTPlayPage new saveContent: '42').
 cm openWithSpec
]]]


!! Make a Spec presentation for the GT Inspector

The inverse of the previous tip can also be realized, in a way: It is possible to write code for a GT Inspector tab such that the tab shows a Spec UI. To do this the ==display:== block of the tab should evaluate to a ==ComposableModel== instance that has been set up completely by sending it the ==buildWithSpec== message.

For example, the code next is for a tab for ==OrderedCollection==, showing all items in the collection as a ListModel.

[[[
OrderedCollection >> gtInspectorItemsAsListIn: composite
	<gtInspectorPresentationOrder: 10>
	 composite spec
	 	 title: 'AsList';
	 	 display: [ :elt | | cm |
	 	 	 cm := ListModel new.
	 	 	 cm items: self.
	 	 	 cm buildWithSpec.
	 	 	 cm]
]]]


@@note By combining the above with the previous tip, it is now possible to achieve Infinite Inspector Recursion between Spec and Glamour UIs:

[[[
Object >> gtInspectorRecursive: composite
	<gtInspectorPresentationOrder: 10>
	 composite spec
	 	 title: 'Recursion!';
	 	 display: [ :elt | | cm |
	 	 	 cm := GlamourPresentationModel new.
	 	 	 cm presentationClass: GTInspector startOn: self.
	 	 	 cm buildWithSpec.
	 	 	 cm]
]]]

!! Customizing the appearance of a widget

If Spec does not allow you to customize the appearance of a widget,
but the underlying widget library does, you can send messages to the
widget just after it has been built. For this, configure the widget
with the ==whenBuiltDo:== message. The argument is a block that takes
one argument, which will be an instance of a ==WidgetBuilt== announcement.

For example, the code below assumes the use of Morphic and results in the label being
rendered in red, and using the Balloon font in Italic.

[[[
|container|
  container := DynamicComposableModel new.
  container instantiateModels:  #(#red LabelModel).
  container red label: 'I am red'.
  container red whenBuiltDo: [:ann|
	  ann widget color: (Color red);
         font: BalloonMorph balloonFont emphasis: 2].
  container layout: (SpecLayout composed add: #red; yourself).
  container openWithSpec
]]]

@@note Warning: By doing the above you are tightly coupling your UI to the underlying widget library. As a result, your UI may break if there are changes in this library, or if Spec uses another library for its underlying widgets.


!! A scrollable list of widgets

==ListModel== can show more than just text, it can also visualize any
kind of widget. To do this, in the ==displayBlock:== send the widgets the ==buildWithSpec== message. This allows to create, e.g. a scrollable list of buttons that reveal information about the classes in the ''Files'' package:

[[[
ListModel new
	displayBlock: [ :x | x buildWithSpec ];
	items:
		('Files' asPackage classes
			collect: [ :cls |
				ButtonModel new	icon: cls systemIcon; label: cls name;
					action: [TextModel new text: cls comment; openWithSpec]]);
	openWithSpec
]]]

+The Scrollable List of Widgets>file://figures/scrollable_buttons.png|width=30|label=fig_scrollable_buttons+


!! Show a table-like view

There are multiple ways in which a table-like widget can be shown to the user. The most straightforward way is the ==MultiColumnListModel==, for example as below. Note that the display block needs to be set to return the item itself, since the default behavior of the display block turns the array into its ==printString==.

[[[
MultiColumnListModel new
	items: {
		{'Origin' . 'Destination' . 'Start Time' . 'Stop Time'} .
		{'Santiago' . 'Paris' . '15:30' . '11:15'} .
		{'Paris' . 'Santiago' . '23:30' . '8:00'} . };
	displayBlock: [ :x | x ];
	openWithSpec.
]]]

Alternatively, a ==TreeModel== can be used, which allows for more fancy formatting options. (This example thanks to Nicolai Hess)

[[[
|r m col1 col2 col3|
 r := FileLocator vmDirectory.
 m := TreeModel new.
 m roots: r allFiles.
 m rootNodeHolder: [ :item |
    TreeNodeModel new
        content: item;
        icon: Smalltalk ui icons smallLeftFlushIcon ].
 m title: r fullName.
 col1 := TreeColumnModel new
    displayBlock: [ :node | node content basename ];
    headerLabel:'Name'.
 col2 := TreeColumnModel new
    displayBlock: [ :node | node content creationTime ];
    headerLabel:'Time'.
 col3 := TreeColumnModel new
    displayBlock: [ :node | node content permissions];
    headerLabel:'Permissions'.
  m columns: {col1. col2 . col3}.
  m openWithSpec.
]]]


!! Non-editable multiline text

The ==TextInputFieldModel== can be configured such that the text it contains is not editable, by disabling it:

[[[
TextInputFieldModel new
	text: ('qwerty\asdfgh\zxcvbn' withCRs );
	enabled: false;
	openWithSpec
]]]

!! List items do not update automatically

Adding items to a collection held in a list does ''not'' update the widget. A refresh only happens when the items of the list are set using the ==items:== message. Note that setting the items also sorts them if a sort block is specified.

[[[
|container count|
 count :=0.
 container := DynamicComposableModel new.
 container instantiateModels:  #(#list ListModel #plus ButtonModel).
 container plus label: '+1'.
 container plus action: [ | items |
   count := count + 1.
   items := container list getList asOrderedCollection.
   items add: count asString.
   container list items: items ].
 container layout:
   (SpecRowLayout composed add: #list ; add: #plus ; yourself).
 container openWithSpec
]]]

!! Get called at periodic intervals 

Morphic implements a `stepping' mechanism that allows a morph to register itself for callbacks that are executed at regular intervals. This allows, e.g. for automatic refreshing of a windows' content every ''n'' milliseconds. Spec also provides support for this, by overriding ==ComposableModel=='s method  ==defaultWindowModelClass== to return a ==TickingWindowModel==. An example of this can be found in the Pharo 5 image in the ==WatchPointWindow== class:

[[[
WatchpointWindow >> defaultWindowModelClass
	^ TickingWindowModel 
]]]

With this override set, every ==stepTime== milliseconds the ==step== method will be called by the Morphic infrastructure. The default implementation of ==step== does nothing, and ==stepTime== returns 1000. So at least ==step== should be overriden to implement the required action. For example, the ==WatchPointWindow==  does not override ==stepTime== and implements ==step== as below, refreshing the list that is shown. 

[[[
WatchpointWindow >> step
	self refreshItems 
]]]

[[[
WatchpointWindow >> refreshItems
	| max values |
	values := self watchpoint values.
	max := values size.
	list items: (values copyFrom: (1 max: max - numItems) to: max) reversed. 
]]]


!! Testing the functionality of a Spec UI

@@todo JF WRITE ME

This code literally runs the tests sequences over the calculator GUI’s key buttons and checks the result in the display input field — pretty cool, no ?

[[[
setUp
  calculator := HP35CalculatorUIModel new.
  calculator openWithSpec

tearDown
  calculator window close

runSequence: script
  script pairsDo: [ :key :result |
    (calculator perform: key) performAction.
    self
      assert: calculator display text
      equals: result asString asUppercase ]
]]]

!! More to add

TreeModel, see mail thread "TreeModel: Updating the tree selection after a deletion" Thanks to Nicolai Hess\

Check http://www.smalltalkhub.com/#!/~hernan/SpecUIAddOns for interesting things

